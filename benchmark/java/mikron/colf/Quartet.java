package mikron.colf;


// This file was generated by colf(1); DO NOT EDIT


import static java.lang.String.format;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.InputMismatchException;
import java.nio.BufferOverflowException;
import java.nio.BufferUnderflowException;


/**
 * Data bean with built-in serialization support.
 * @author generated by colf(1)
 * @see <a href="https://github.com/pascaldekloe/colfer">Colfer's home</a>
 */
public class Quartet implements java.io.Serializable {

	/** The upper limit for serial byte sizes. */
	public static int colferSizeMax = 16 * 1024 * 1024;


	public Person p1;
	public Person p2;
	public Person p3;
	public Person p4;


	/**
	 * {@link #reset(InputStream) Reusable} deserialization of Colfer streams.
	 */
	public static class Unmarshaller {

		/** The data source. */
		protected InputStream in;

		/** The read buffer. */
		protected byte[] buf;

		/** The {@link #buf buffer}'s data start index, inclusive. */
		protected int offset;

		/** The {@link #buf buffer}'s data end index, exclusive. */
		protected int i;


		/**
		 * @param in the data source or {@code null}.
		 * @param buf the initial buffer or {@code null}.
		 */
		public Unmarshaller(InputStream in, byte[] buf) {
			if (buf == null || buf.length == 0)
				buf = new byte[Math.min(Quartet.colferSizeMax, 2048)];
			this.buf = buf;
			reset(in);
		}

		/**
		 * Reuses the marshaller.
		 * @param in the data source or {@code null}.
		 * @throws IllegalStateException on pending data.
		 */
		public void reset(InputStream in) {
			if (this.i != this.offset) throw new IllegalStateException("colfer: pending data");
			this.in = in;
			this.offset = 0;
			this.i = 0;
		}

		/**
		 * Deserializes the following object.
		 * @return the result or {@code null} when EOF.
		 * @throws IOException from the input stream.
		 * @throws SecurityException on an upper limit breach defined by {@link #colferSizeMax}.
		 * @throws InputMismatchException when the data does not match this object's schema.
		 */
		public Quartet next() throws IOException {
			if (in == null) return null;

			while (true) {
				if (this.i > this.offset) {
					try {
						Quartet o = new Quartet();
						this.offset = o.unmarshal(this.buf, this.offset, this.i);
						return o;
					} catch (BufferUnderflowException e) {
					}
				}
				// not enough data

				if (this.i <= this.offset) {
					this.offset = 0;
					this.i = 0;
				} else if (i == buf.length) {
					byte[] src = this.buf;
					if (offset == 0) this.buf = new byte[Math.min(Quartet.colferSizeMax, this.buf.length * 4)];
					System.arraycopy(src, this.offset, this.buf, 0, this.i - this.offset);
					this.i -= this.offset;
					this.offset = 0;
				}
				assert this.i < this.buf.length;

				int n = in.read(buf, i, buf.length - i);
				if (n < 0) {
					if (this.i > this.offset)
						throw new InputMismatchException("colfer: pending data with EOF");
					return null;
				}
				assert n > 0;
				i += n;
			}
		}

	}


	/**
	 * Serializes the object.
	 * @param out the data destination.
	 * @param buf the initial buffer or {@code null}.
	 * @return the final buffer. When the serial fits into {@code buf} then the return is {@code buf}.
	 *  Otherwise the return is a new buffer, large enough to hold the whole serial.
	 * @throws IOException from {@code out}.
	 * @throws IllegalStateException on an upper limit breach defined by {@link #colferSizeMax}.
	 */
	public byte[] marshal(OutputStream out, byte[] buf) throws IOException {
		if (buf == null || buf.length == 0)
			buf = new byte[Math.min(Quartet.colferSizeMax, 2048)];

		while (true) {
			int i;
			try {
				i = marshal(buf, 0);
			} catch (BufferOverflowException e) {
				buf = new byte[Math.min(Quartet.colferSizeMax, buf.length * 4)];
				continue;
			}

			out.write(buf, 0, i);
			return buf;
		}
	}

	/**
	 * Serializes the object.
	 * @param buf the data destination.
	 * @param offset the initial index for {@code buf}, inclusive.
	 * @return the final index for {@code buf}, exclusive.
	 * @throws BufferOverflowException when {@code buf} is too small.
	 * @throws IllegalStateException on an upper limit breach defined by {@link #colferSizeMax}.
	 */
	public int marshal(byte[] buf, int offset) {
		int i = offset;

		try {
			if (this.p1 != null) {
				buf[i++] = (byte) 0;
				i = this.p1.marshal(buf, i);
			}

			if (this.p2 != null) {
				buf[i++] = (byte) 1;
				i = this.p2.marshal(buf, i);
			}

			if (this.p3 != null) {
				buf[i++] = (byte) 2;
				i = this.p3.marshal(buf, i);
			}

			if (this.p4 != null) {
				buf[i++] = (byte) 3;
				i = this.p4.marshal(buf, i);
			}

			buf[i++] = (byte) 0x7f;
			return i;
		} catch (ArrayIndexOutOfBoundsException e) {
			if (i - offset > Quartet.colferSizeMax)
				throw new IllegalStateException(format("colfer: mikron.Quartet exceeds %d bytes", Quartet.colferSizeMax));
			if (i > buf.length) throw new BufferOverflowException();
			throw e;
		}
	}

	/**
	 * Deserializes the object.
	 * @param buf the data source.
	 * @param offset the initial index for {@code buf}, inclusive.
	 * @return the final index for {@code buf}, exclusive.
	 * @throws BufferUnderflowException when {@code buf} is incomplete. (EOF)
	 * @throws SecurityException on an upper limit breach defined by {@link #colferSizeMax}.
	 * @throws InputMismatchException when the data does not match this object's schema.
	 */
	public int unmarshal(byte[] buf, int offset) {
		return unmarshal(buf, offset, buf.length);
	}

	/**
	 * Deserializes the object.
	 * @param buf the data source.
	 * @param offset the initial index for {@code buf}, inclusive.
	 * @param end the index limit for {@code buf}, exclusive.
	 * @return the final index for {@code buf}, exclusive.
	 * @throws BufferUnderflowException when {@code buf} is incomplete. (EOF)
	 * @throws SecurityException on an upper limit breach defined by {@link #colferSizeMax}.
	 * @throws InputMismatchException when the data does not match this object's schema.
	 */
	public int unmarshal(byte[] buf, int offset, int end) {
		if (end > buf.length) end = buf.length;
		int i = offset;

		try {
			byte header = buf[i++];

			if (header == (byte) 0) {
				this.p1 = new Person();
				i = this.p1.unmarshal(buf, i, end);
				header = buf[i++];
			}

			if (header == (byte) 1) {
				this.p2 = new Person();
				i = this.p2.unmarshal(buf, i, end);
				header = buf[i++];
			}

			if (header == (byte) 2) {
				this.p3 = new Person();
				i = this.p3.unmarshal(buf, i, end);
				header = buf[i++];
			}

			if (header == (byte) 3) {
				this.p4 = new Person();
				i = this.p4.unmarshal(buf, i, end);
				header = buf[i++];
			}

			if (header != (byte) 0x7f)
				throw new InputMismatchException(format("colfer: unknown header at byte %d", i - 1));
		} finally {
			if (i > end && end - offset < Quartet.colferSizeMax) throw new BufferUnderflowException();
			if (i - offset > Quartet.colferSizeMax)
				throw new SecurityException(format("colfer: mikron.Quartet exceeds %d bytes", Quartet.colferSizeMax));
			if (i > end) throw new BufferUnderflowException();
		}

		return i;
	}

	public Person getP1() {
		return this.p1;
	}

	public void setP1(Person value) {
		this.p1 = value;
	}

	public Person getP2() {
		return this.p2;
	}

	public void setP2(Person value) {
		this.p2 = value;
	}

	public Person getP3() {
		return this.p3;
	}

	public void setP3(Person value) {
		this.p3 = value;
	}

	public Person getP4() {
		return this.p4;
	}

	public void setP4(Person value) {
		this.p4 = value;
	}

	@Override
	public final int hashCode() {
		int h = 1;
		if (this.p1 != null) h = 31 * h + this.p1.hashCode();
		if (this.p2 != null) h = 31 * h + this.p2.hashCode();
		if (this.p3 != null) h = 31 * h + this.p3.hashCode();
		if (this.p4 != null) h = 31 * h + this.p4.hashCode();
		return h;
	}

	@Override
	public final boolean equals(Object o) {
		return o instanceof Quartet && equals((Quartet) o);
	}

	public final boolean equals(Quartet o) {
		return o != null && o.getClass() == Quartet.class
			&& this.p1 == null ? o.p1 == null : this.p1.equals(o.p1)
			&& this.p2 == null ? o.p2 == null : this.p2.equals(o.p2)
			&& this.p3 == null ? o.p3 == null : this.p3.equals(o.p3)
			&& this.p4 == null ? o.p4 == null : this.p4.equals(o.p4);
	}

}
