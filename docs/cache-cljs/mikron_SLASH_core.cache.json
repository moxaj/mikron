["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "],"~$Object",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$mikron.core","~:imports",null,"~:requires",["^ ","~$mikron.compile-util","^<","~$mikron.util","^=","~$mikron.buffer","^>","~$mikron.codegen.gen","^?","~$mikron.codegen.validate","^@","~$buffer","^>","~$compile-util","^<","~$mikron.codegen.unpack","^C","~$util","^=","~$mikron.spec","^E","~$mikron.util.math","^F","~$util.math","^F","~$mikron.codegen.pack","^H","~$spec","^E","~$mikron.codegen.interp","^J","~$mikron.codegen.diff","^K"],"~:uses",null,"~:defs",["^ ","~$allocate-buffer",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","^9","~:line",74,"~:column",7,"~:end-line",74,"~:end-column",22,"~:arglists",["~#list",["~$quote",["^W",[["~$size"]]]]],"~:doc","Allocates a new buffer with the given `size`.\n   ~~~klipse\n   (allocate-buffer 2048)\n   ~~~"],"^8","~$mikron.core/allocate-buffer","~:variadic",false,"^Q","mikron/core.cljc","^U",22,"~:method-params",["^W",[["^Y"]]],"~:protocol-impl",null,"~:arglists-meta",["^W",[null,null]],"^S",1,"^R",74,"^T",74,"~:max-fixed-arity",1,"~:fn-var",true,"^V",["^W",["^X",["^W",[["^Y"]]]]],"^Z","Allocates a new buffer with the given `size`.\n   ~~~klipse\n   (allocate-buffer 2048)\n   ~~~"],"~$pack",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",106,"^S",7,"^T",106,"^U",11,"^V",["^W",["^X",["^W",[["~$schema","~$value"]]]]],"^Z","Packs `value`, which must conform to `schema`, and may be an instance of `DiffedValue`.\n   ~~~klipse\n   (let [my-schema (schema [:tuple [:int :keyword]])]\n     (pack my-schema [100 :cat]))\n   ~~~"],"^8","~$mikron.core/pack","^10",false,"^Q","mikron/core.cljc","^U",11,"^11",["^W",[["^17","^18"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",106,"^T",106,"^14",2,"^15",true,"^V",["^W",["^X",["^W",[["^17","^18"]]]]],"^Z","Packs `value`, which must conform to `schema`, and may be an instance of `DiffedValue`.\n   ~~~klipse\n   (let [my-schema (schema [:tuple [:int :keyword]])]\n     (pack my-schema [100 :cat]))\n   ~~~"],"~$dependencies",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",30,"^S",17,"^T",30,"^U",29,"~:private",true,"^V",["^W",["^X",["^W",[["~$processors"]]]]],"^Z","Returns all the processor dependencies of the given processors."],"^1;",true,"^8","~$mikron.core/dependencies","^10",false,"^Q","mikron/core.cljc","^U",29,"^11",["^W",[["^1<"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",30,"^T",30,"^14",1,"^15",true,"^V",["^W",["^X",["^W",[["^1<"]]]]],"^Z","Returns all the processor dependencies of the given processors."],"~$diff",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",186,"^S",7,"^T",186,"^U",11,"^V",["^W",["^X",["^W",[["^17","~$value-1","~$value-2"]]]]],"^Z","Returns the diff between the old (`value-1`) and the new (`value-2`) value, both conforming to `schema`.\n   Wraps the return value with `DiffedValue` for `pack` and `undiff` consumption.\n   ~~~klipse\n   (let [my-schema (schema [:map :byte :keyword]\n                           :diff {:all true})]\n     (diff my-schema {0 :a 1 :b} {0 :a 1 :c 2 :d}))\n   ~~~"],"^8","~$mikron.core/diff","^10",false,"^Q","mikron/core.cljc","^U",11,"^11",["^W",[["^17","^1?","^1@"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",186,"^T",186,"^14",3,"^15",true,"^V",["^W",["^X",["^W",[["^17","^1?","^1@"]]]]],"^Z","Returns the diff between the old (`value-1`) and the new (`value-2`) value, both conforming to `schema`.\n   Wraps the return value with `DiffedValue` for `pack` and `undiff` consumption.\n   ~~~klipse\n   (let [my-schema (schema [:map :byte :keyword]\n                           :diff {:all true})]\n     (diff my-schema {0 :a 1 :b} {0 :a 1 :c 2 :d}))\n   ~~~"],"~$*buffer*",["^ ","^P",["^ ","^Q","^9","^R",70,"^S",26,"^T",70,"^U",34,"^1;",true,"~:dynamic",true],"^1;",true,"^8","~$mikron.core/*buffer*","^Q","mikron/core.cljc","^U",34,"^S",1,"^1C",true,"^R",70,"^T",70,"~:tag","~$any","^Z","The default buffer with 10Kb size."],"^17",["^ ","^O",null,"^P",["^ ","^Q","^9","^U",17,"~:top-fn",["^ ","^10",true,"^14",2,"^11",[["^W",["~$&form","~$&env","~$args"]]],"^V",["^W",[["^1H","^1I","~$&","^1J"]]],"^13",["^W",[null]]],"^S",11,"^R",50,"~:macro",true,"^T",50,"^V",["^W",["^X",["^W",[["~$&","^1J"]]]]],"^Z","Creates a new schema.\n   ~~~klipse\n   (def my-schema\n     (schema [:tuple [:int :string [:enum [:a :b :c]]]]))\n   ~~~"],"^8","~$mikron.core/schema","^10",true,"^Q","mikron/core.cljc","^U",17,"^1G",["^ ","^10",true,"^14",2,"^11",[["^W",["^1H","^1I","^1J"]]],"^V",["^W",[["^1H","^1I","~$&","^1J"]]],"^13",["^W",[null]]],"^11",[["^W",["^1H","^1I","^1J"]]],"^12",null,"^13",["^W",[null]],"^S",1,"^R",50,"^1K",true,"^T",50,"^14",2,"^15",false,"^V",["^W",[["^1H","^1I","~$&","^1J"]]],"^Z","Creates a new schema.\n   ~~~klipse\n   (def my-schema\n     (schema [:tuple [:int :string [:enum [:a :b :c]]]]))\n   ~~~"],"~$DiffedValue",["^ ","~:num-fields",1,"~:protocols",["^7",["~$cljs.core/IRecord","~$cljs.core/IEquiv","~$cljs.core/IHash","~$cljs.core/ICollection","~$cljs.core/ICounted","~$cljs.core/ISeqable","~$cljs.core/IMeta","~$cljs.core/ICloneable","~$cljs.core/IPrintWithWriter","~$cljs.core/IIterable","~$cljs.core/IWithMeta","~$cljs.core/IAssociative","~$cljs.core/IMap","~$cljs.core/ILookup"]],"^8","~$mikron.core/DiffedValue","^Q","mikron/core.cljc","^U",23,"~:type",true,"^S",12,"~:internal-ctor",true,"^R",99,"~:record",true,"^T",99,"~:skip-protocol-flag",["^7",["^1P","^1Q","^1R","^1S","^1T","^1U","^1V","^1W","^1X","^1Z","^1[","^20","^21"]]],"^1<",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",23,"^S",17,"^T",23,"^U",27,"^1;",true,"^V",["^W",["^X",["^W",[["~$env"]]]]],"^Z","Returns all the generated processors for the given env."],"^1;",true,"^8","~$mikron.core/processors","^10",false,"^Q","mikron/core.cljc","^U",27,"^11",["^W",[["^27"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",23,"^T",23,"^14",1,"^15",true,"^V",["^W",["^X",["^W",[["^27"]]]]],"^Z","Returns all the generated processors for the given env."],"~$valid?",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",149,"^S",7,"^T",149,"^U",13,"^V",["^W",["^X",["^W",[["^17","^18"]]]]],"^Z","Returns `true` if `value` conforms to `schema`, `false` otherwise.\n   ~~~klipse\n   (let [my-schema (schema [:vector :byte])]\n     (valid? my-schema [0 1 2 3 4 5]))\n   ~~~"],"^8","~$mikron.core/valid?","^10",false,"^Q","mikron/core.cljc","^U",13,"^11",["^W",[["^17","^18"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",149,"^T",149,"^14",2,"^15",true,"^V",["^W",["^X",["^W",[["^17","^18"]]]]],"^Z","Returns `true` if `value` conforms to `schema`, `false` otherwise.\n   ~~~klipse\n   (let [my-schema (schema [:vector :byte])]\n     (valid? my-schema [0 1 2 3 4 5]))\n   ~~~"],"~$undiff",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",199,"^S",7,"^T",199,"^U",13,"^V",["^W",["^X",["^W",[["^17","^1?","^1@"]]]]],"^Z","Returns the original value from the old (`value-1`) and the diffed (`value-2`) value. The old value must conform to\n   `schema`. `value-2` must be an instance of `DiffedValue`.\n   ~~~klipse\n   (let [my-schema (schema [:map :byte :keyword]\n                           :diff {:all true})\n         old-value {0 :a 1 :b}]\n     (->> {0 :a 1 :c 2 :d} (diff my-schema old-value) (undiff my-schema old-value)))\n   ~~~"],"^8","~$mikron.core/undiff","^10",false,"^Q","mikron/core.cljc","^U",13,"^11",["^W",[["^17","^1?","^1@"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",199,"^T",199,"^14",3,"^15",true,"^V",["^W",["^X",["^W",[["^17","^1?","^1@"]]]]],"^Z","Returns the original value from the old (`value-1`) and the diffed (`value-2`) value. The old value must conform to\n   `schema`. `value-2` must be an instance of `DiffedValue`.\n   ~~~klipse\n   (let [my-schema (schema [:map :byte :keyword]\n                           :diff {:all true})\n         old-value {0 :a 1 :b}]\n     (->> {0 :a 1 :c 2 :d} (diff my-schema old-value) (undiff my-schema old-value)))\n   ~~~"],"~$set-byte-buffer-factory!",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",83,"^S",7,"^T",83,"^U",31,"^V",["^W",["^X",["^W",[["~$factory"]]]]],"^Z","Sets the byte buffer factory."],"^8","~$mikron.core/set-byte-buffer-factory!","^10",false,"^Q","mikron/core.cljc","^U",31,"^11",["^W",[["^2>"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",83,"^T",83,"^14",1,"^15",true,"^V",["^W",["^X",["^W",[["^2>"]]]]],"^Z","Sets the byte buffer factory."],"~$gen",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",138,"^S",7,"^T",138,"^U",10,"^V",["^W",["^X",["^W",[["^17"]]]]],"^Z","Generates a new value which conforms to `schema`.\n   ~~~klipse\n   (let [my-schema (schema [:multi number? {true :ubyte false [:enum [:a :b :c]]}])]\n     (repeatedly 10 #(gen my-schema)))\n   ~~~"],"^8","~$mikron.core/gen","^10",false,"^Q","mikron/core.cljc","^U",10,"^11",["^W",[["^17"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",138,"^T",138,"^14",1,"^15",true,"^V",["^W",["^X",["^W",[["^17"]]]]],"^Z","Generates a new value which conforms to `schema`.\n   ~~~klipse\n   (let [my-schema (schema [:multi number? {true :ubyte false [:enum [:a :b :c]]}])]\n     (repeatedly 10 #(gen my-schema)))\n   ~~~"],"~$diffed?",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",101,"^S",17,"^T",101,"^U",24,"^1;",true,"^V",["^W",["^X",["^W",[["^18"]]]]],"^Z","Returns `true` if `value` is diffed, `false` otherwise."],"^1;",true,"^8","~$mikron.core/diffed?","^10",false,"^Q","mikron/core.cljc","^U",24,"^11",["^W",[["^18"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",101,"^T",101,"^14",1,"^15",true,"^V",["^W",["^X",["^W",[["^18"]]]]],"^Z","Returns `true` if `value` is diffed, `false` otherwise."],"~$defschema",["^ ","^O",null,"^P",["^ ","^Q","^9","^U",20,"^1G",["^ ","^10",true,"^14",2,"^11",[["^W",["^1H","^1I","^1J"]]],"^V",["^W",[["^1H","^1I","~$&","^1J"]]],"^13",["^W",[null]]],"^S",11,"^R",59,"^1K",true,"^T",59,"^V",["^W",["^X",["^W",[["~$&","^1J"]]]]],"^Z","Creates a new schema and binds it to the given symbol.\n   ~~~klipse\n   (defschema my-schema\n     [:record {:a :keyword :b :ubyte}])\n   ~~~"],"^8","~$mikron.core/defschema","^10",true,"^Q","mikron/core.cljc","^U",20,"^1G",["^ ","^10",true,"^14",2,"^11",[["^W",["^1H","^1I","^1J"]]],"^V",["^W",[["^1H","^1I","~$&","^1J"]]],"^13",["^W",[null]]],"^11",[["^W",["^1H","^1I","^1J"]]],"^12",null,"^13",["^W",[null]],"^S",1,"^R",59,"^1K",true,"^T",59,"^14",2,"^15",false,"^V",["^W",[["^1H","^1I","~$&","^1J"]]],"^Z","Creates a new schema and binds it to the given symbol.\n   ~~~klipse\n   (defschema my-schema\n     [:record {:a :keyword :b :ubyte}])\n   ~~~"],"~$unpack",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",122,"^S",7,"^T",122,"^U",13,"^V",["^W",["^X",["^W",[["^17","~$binary"]]]]],"^Z","Unpacks a value (which conforms to `schema`) from the binary value `binary`.\n   ~~~klipse\n   (let [my-schema (schema [:tuple [:int :keyword]])]\n     (->> [100 :cat] (pack my-schema) (unpack my-schema)))\n   ~~~"],"^8","~$mikron.core/unpack","^10",false,"^Q","mikron/core.cljc","^U",13,"^11",["^W",[["^17","^2G"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",122,"^T",122,"^14",2,"^15",true,"^V",["^W",["^X",["^W",[["^17","^2G"]]]]],"^Z","Unpacks a value (which conforms to `schema`) from the binary value `binary`.\n   ~~~klipse\n   (let [my-schema (schema [:tuple [:int :keyword]])]\n     (->> [100 :cat] (pack my-schema) (unpack my-schema)))\n   ~~~"],"~$diff*",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",160,"^S",7,"^T",160,"^U",12,"^V",["^W",["^X",["^W",[["^17","^1?","^1@"]]]]],"^Z","Returns the diff between the old (`value-1`) and the new (`value-2`) value, both conforming to `schema`.\n   ~~~klipse\n   (let [my-schema (schema [:vector [:enum [:a :b]]]\n                           :diff {:all true})]\n     (diff* my-schema [:a :b :a :a] [:b :b :a :b]))\n   ~~~"],"^8","~$mikron.core/diff*","^10",false,"^Q","mikron/core.cljc","^U",12,"^11",["^W",[["^17","^1?","^1@"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",160,"^T",160,"^14",3,"^15",true,"^V",["^W",["^X",["^W",[["^17","^1?","^1@"]]]]],"^Z","Returns the diff between the old (`value-1`) and the new (`value-2`) value, both conforming to `schema`.\n   ~~~klipse\n   (let [my-schema (schema [:vector [:enum [:a :b]]]\n                           :diff {:all true})]\n     (diff* my-schema [:a :b :a :a] [:b :b :a :b]))\n   ~~~"],"~$->DiffedValue",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",99,"^S",12,"^T",99,"^U",23,"^24",true,"~:factory","~:positional","^V",["^W",["^X",["^W",[["^18"]]]]]],"^8","~$mikron.core/->DiffedValue","^10",false,"^Q","mikron/core.cljc","^U",23,"^11",["^W",[["^18"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^24",true,"^2L","^2M","^R",99,"^T",99,"^14",1,"^15",true,"^V",["^W",["^X",["^W",[["^18"]]]]]],"~$->Schema",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",16,"^S",12,"^T",16,"^U",18,"^24",true,"^2L","^2M","^V",["^W",["^X",["^W",[["^1<"]]]]]],"^8","~$mikron.core/->Schema","^10",false,"^Q","mikron/core.cljc","^U",18,"^11",["^W",[["^1<"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^24",true,"^2L","^2M","^R",16,"^T",16,"^14",1,"^15",true,"^V",["^W",["^X",["^W",[["^1<"]]]]]],"~$schema*",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",38,"^S",17,"^T",38,"^U",24,"^1;",true,"^V",["^W",["^X",["^W",[["^27"]]]]],"^Z","Generates all the processor related code for the given env."],"^1;",true,"^8","~$mikron.core/schema*","^10",false,"^Q","mikron/core.cljc","^U",24,"^11",["^W",[["^27"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",38,"^T",38,"^14",1,"^15",true,"^V",["^W",["^X",["^W",[["^27"]]]]],"^Z","Generates all the processor related code for the given env."],"~$schema?",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",18,"^S",7,"^T",18,"^U",14,"^V",["^W",["^X",["^W",[["^18"]]]]],"^Z","Returns `true` if `value` is an instance of `Schema`, `false` otherwise."],"^8","~$mikron.core/schema?","^10",false,"^Q","mikron/core.cljc","^U",14,"^11",["^W",[["^18"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",18,"^T",18,"^14",1,"^15",true,"^V",["^W",["^X",["^W",[["^18"]]]]],"^Z","Returns `true` if `value` is an instance of `Schema`, `false` otherwise."],"~$map->DiffedValue",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",99,"^S",12,"^T",99,"^U",23,"^24",true,"^2L","~:map","^V",["^W",["^X",["^W",[["~$G__918"]]]]]],"^8","~$mikron.core/map->DiffedValue","^10",false,"^Q","mikron/core.cljc","^U",23,"^11",["^W",[["^2W"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^24",true,"^2L","^2V","^R",99,"^T",99,"^14",1,"^15",true,"^V",["^W",["^X",["^W",[["^2W"]]]]]],"~$interp",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",213,"^S",7,"^T",213,"^U",13,"^V",["^W",["^X",["^W",[["^17","^1?","^1@","~$time-1","~$time-2","~$time"]]]]],"^Z","Calculates a new value of an entity at `time`, given two other values (`value-1` and `value-2`, both conforming to\n   `schema`) and their respective timestamps (`time-1` and `time-2`). Uses linear interpolation.\n   ~~~klipse\n   (let [my-schema (schema [:record {:a :float :b [:vector :float]}]\n                           :interp {:a true :b {:all true}})]\n     (interp my-schema {:a 10 :b [1 2 3]} {:a 20 :b [4 5 6 7]} 0 1 0.5))\n   ~~~"],"^8","~$mikron.core/interp","^10",false,"^Q","mikron/core.cljc","^U",13,"^11",["^W",[["^17","^1?","^1@","^2Z","^2[","^30"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",213,"^T",213,"^14",6,"^15",true,"^V",["^W",["^X",["^W",[["^17","^1?","^1@","^2Z","^2[","^30"]]]]],"^Z","Calculates a new value of an entity at `time`, given two other values (`value-1` and `value-2`, both conforming to\n   `schema`) and their respective timestamps (`time-1` and `time-2`). Uses linear interpolation.\n   ~~~klipse\n   (let [my-schema (schema [:record {:a :float :b [:vector :float]}]\n                           :interp {:a true :b {:all true}})]\n     (interp my-schema {:a 10 :b [1 2 3]} {:a 20 :b [4 5 6 7]} 0 1 0.5))\n   ~~~"],"~$with-buffer",["^ ","^O",null,"^P",["^ ","^Q","^9","^U",22,"^1G",["^ ","^10",true,"^14",3,"^11",[["^W",["^1H","^1I","^A","~$body"]]],"^V",["^W",[["^1H","^1I","^A","~$&","^33"]]],"^13",["^W",[null]]],"^S",11,"^R",88,"^1K",true,"^T",88,"^V",["^W",["^X",["^W",[["^A","~$&","^33"]]]]],"^Z","Executes all the expressions of `body` in the context of `buffer`.\n   ~~~klipse\n   (let [my-schema (schema [:list :int])]\n     (with-buffer (allocate-buffer 10000)\n       (pack my-schema (repeatedly 2000 #(rand-int 1000)))))\n   ~~~"],"^8","~$mikron.core/with-buffer","^10",true,"^Q","mikron/core.cljc","^U",22,"^1G",["^ ","^10",true,"^14",3,"^11",[["^W",["^1H","^1I","^A","^33"]]],"^V",["^W",[["^1H","^1I","^A","~$&","^33"]]],"^13",["^W",[null]]],"^11",[["^W",["^1H","^1I","^A","^33"]]],"^12",null,"^13",["^W",[null]],"^S",1,"^R",88,"^1K",true,"^T",88,"^14",3,"^15",false,"^V",["^W",[["^1H","^1I","^A","~$&","^33"]]],"^Z","Executes all the expressions of `body` in the context of `buffer`.\n   ~~~klipse\n   (let [my-schema (schema [:list :int])]\n     (with-buffer (allocate-buffer 10000)\n       (pack my-schema (repeatedly 2000 #(rand-int 1000)))))\n   ~~~"],"~$map->Schema",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",16,"^S",12,"^T",16,"^U",18,"^24",true,"^2L","^2V","^V",["^W",["^X",["^W",[["~$G__872"]]]]]],"^8","~$mikron.core/map->Schema","^10",false,"^Q","mikron/core.cljc","^U",18,"^11",["^W",[["^36"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^24",true,"^2L","^2V","^R",16,"^T",16,"^14",1,"^15",true,"^V",["^W",["^X",["^W",[["^36"]]]]]],"~$Schema",["^ ","^1N",1,"^1O",["^7",["^1P","^1Q","^1R","^1S","^1T","^1U","^1V","^1W","^1X","^1Y","^1Z","^1[","^20","^21"]],"^8","~$mikron.core/Schema","^Q","mikron/core.cljc","^U",18,"^23",true,"^S",12,"^24",true,"^R",16,"^25",true,"^T",16,"^26",["^7",["^1P","^1Q","^1R","^1S","^1T","^1U","^1V","^1W","^1X","^1Z","^1[","^20","^21"]]],"~$undiff*",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",172,"^S",7,"^T",172,"^U",14,"^V",["^W",["^X",["^W",[["^17","^1?","^1@"]]]]],"^Z","Returns the original value from the old (`value-1`) and the diffed (`value-2`) value.\n   The old value must conform to `schema`.\n   ~~~klipse\n   (let [my-schema (schema [:vector [:enum [:a :b]]]\n                           :diff {:all true})\n         old-value [:a :b :a :a]]\n     (->> [:b :b :a :b] (diff* my-schema old-value) (undiff* my-schema old-value)))\n   ~~~"],"^8","~$mikron.core/undiff*","^10",false,"^Q","mikron/core.cljc","^U",14,"^11",["^W",[["^17","^1?","^1@"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",172,"^T",172,"^14",3,"^15",true,"^V",["^W",["^X",["^W",[["^17","^1?","^1@"]]]]],"^Z","Returns the original value from the old (`value-1`) and the diffed (`value-2`) value.\n   The old value must conform to `schema`.\n   ~~~klipse\n   (let [my-schema (schema [:vector [:enum [:a :b]]]\n                           :diff {:all true})\n         old-value [:a :b :a :a]]\n     (->> [:b :b :a :b] (diff* my-schema old-value) (undiff* my-schema old-value)))\n   ~~~"]],"~:require-macros",["^ ","^9","^9"],"~:cljs.analyzer/constants",["^ ","~:seen",["^7",["^2P","~$&","^2R","^33","^9","~$cljs.core/binding","^2[","~:unpack-diffed","^N","^16","^1:","~:processors","~:valid?","^2N","^A","~:diffed?","^1>","^1;","~:else","^34","~:undiff","~:gen","^2G","^1B","^1J","^31","~:processor-fn","~:ns","^17","^8","^1H","^2J","^1A","^10","~:value","^2H","^3;","^Q","~$.-processors","~:unpack","^U","^1G","^19","~$mikron.core/Schema.","^1<","^29","^2;","^11","^2=","^2@","^2T","^2B","^13","~:doc-string","^2X","~:processor-type","^2D","^S","^18","^24","^36","~$cljs.core/let","^1@","^2F","^30","^2M","^1D","^2I","^2<","^2L","^2Z","^2K","^2?","~:interp","^1C","^R","^1K","^[","^27","~:mikron.spec/schema-args","^1L","~:mikron.spec/defschema-args","^2O","^1I","^2Q","^2S","~$cljs.core/fn","~:mikron/invalid","^37","^Y","^T","^2A","^1?","^2U","^2C","^14","^2>","^2:","^28","^2E","^2Y","^V","~:pack-diffed","^32","^Z","^35","^2V","~:pack","~:test","^1=","~:schema-name","~$def","~:diff","^2W","^3:"]],"~:order",["^3A","^1<","^2P","^3H","^8","^Q","^U","^S","^24","^2L","^R","^T","^V","^Z","^3W","^9","^2O","^2M","^37","^35","^2V","^36","^2T","^2S","^18","^3N","^3G","^3S","^28","^1;","^27","^3X","^1=","^1:","^3O","^3J","^3L","^2R","^2Q","^1L","^1G","^1K","^17","^10","^14","^11","^13","^1H","^1I","^1J","~$&","^3Q","^2E","^2D","^3R","^3M","^3Y","^1D","^1C","^1B","^[","^N","^Y","^2?","^2=","^2>","^34","^32","^A","^33","^3?","^3I","^2N","^2K","^2X","^2U","^2W","^2C","^2B","^3U","^3V","^19","^16","^3T","^3D","^3C","^3@","^3K","^2H","^2F","^2G","^3F","^2A","^2@","^3B","^2:","^29","^3Z","^2J","^2I","^1?","^1@","^3E","^3;","^3:","^1A","^1>","^2<","^2;","^3P","^31","^2Y","^2Z","^2[","^30"]],"^Z","Core namespace."]