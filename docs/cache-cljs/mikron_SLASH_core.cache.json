["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "],"~$Object",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$mikron.core","~:imports",null,"~:requires",["^ ","~$mikron.compile-util","^<","~$mikron.util","^=","~$mikron.buffer","^>","~$mikron.codegen.gen","^?","~$mikron.codegen.validate","^@","~$buffer","^>","~$compile-util","^<","~$mikron.codegen.unpack","^C","~$util","^=","~$mikron.spec","^E","~$mikron.util.math","^F","~$util.math","^F","~$mikron.codegen.pack","^H","~$spec","^E","~$mikron.codegen.interp","^J","~$mikron.codegen.diff","^K"],"~:uses",null,"~:defs",["^ ","~$allocate-buffer",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","^9","~:line",73,"~:column",7,"~:end-line",73,"~:end-column",22,"~:arglists",["~#list",["~$quote",["^W",[["~$size"]]]]],"~:doc","Allocates a new buffer with the given `size`.\n   ~~~klipse\n   (js/console.log \"b\")\n   (allocate-buffer 2048)\n   ~~~"],"^8","~$mikron.core/allocate-buffer","~:variadic",false,"^Q","mikron/core.cljc","^U",22,"~:method-params",["^W",[["^Y"]]],"~:protocol-impl",null,"~:arglists-meta",["^W",[null,null]],"^S",1,"^R",73,"^T",73,"~:max-fixed-arity",1,"~:fn-var",true,"^V",["^W",["^X",["^W",[["^Y"]]]]],"^Z","Allocates a new buffer with the given `size`.\n   ~~~klipse\n   (js/console.log \"b\")\n   (allocate-buffer 2048)\n   ~~~"],"~$pack",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",101,"^S",7,"^T",101,"^U",11,"^V",["^W",["^X",["^W",[["~$schema","~$value"]]]]],"^Z","Packs `value`, which must conform to `schema`, and may be an instance of\n   `DiffedValue`.\n   ~~~klipse\n   (let [s (schema [:tuple [:int :keyword]])]\n     (pack s [100 :cat]))\n   ~~~"],"^8","~$mikron.core/pack","^10",false,"^Q","mikron/core.cljc","^U",11,"^11",["^W",[["^17","^18"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",101,"^T",101,"^14",2,"^15",true,"^V",["^W",["^X",["^W",[["^17","^18"]]]]],"^Z","Packs `value`, which must conform to `schema`, and may be an instance of\n   `DiffedValue`.\n   ~~~klipse\n   (let [s (schema [:tuple [:int :keyword]])]\n     (pack s [100 :cat]))\n   ~~~"],"~$dependencies",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",30,"^S",17,"^T",30,"^U",29,"~:private",true,"^V",["^W",["^X",["^W",[["~$processors"]]]]],"^Z","Returns all the processor dependencies of the given processors."],"^1;",true,"^8","~$mikron.core/dependencies","^10",false,"^Q","mikron/core.cljc","^U",29,"^11",["^W",[["^1<"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",30,"^T",30,"^14",1,"^15",true,"^V",["^W",["^X",["^W",[["^1<"]]]]],"^Z","Returns all the processor dependencies of the given processors."],"~$diff",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",172,"^S",7,"^T",172,"^U",11,"^V",["^W",["^X",["^W",[["^17","~$value-1","~$value-2"]]]]],"^Z","Returns the diff between the old (`value-1`) and the new (`value-2`) value,\n  both conforming to `schema`. Wraps the return value with `DiffedValue` for `pack`\n  and `undiff` consumption."],"^8","~$mikron.core/diff","^10",false,"^Q","mikron/core.cljc","^U",11,"^11",["^W",[["^17","^1?","^1@"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",172,"^T",172,"^14",3,"^15",true,"^V",["^W",["^X",["^W",[["^17","^1?","^1@"]]]]],"^Z","Returns the diff between the old (`value-1`) and the new (`value-2`) value,\n  both conforming to `schema`. Wraps the return value with `DiffedValue` for `pack`\n  and `undiff` consumption."],"~$*buffer*",["^ ","^P",["^ ","^Q","^9","^R",69,"^S",26,"^T",69,"^U",34,"^1;",true,"~:dynamic",true],"^1;",true,"^8","~$mikron.core/*buffer*","^Q","mikron/core.cljc","^U",34,"^S",1,"^1C",true,"^R",69,"^T",69,"~:tag","~$any","^Z","The default buffer with 10Kb size."],"^17",["^ ","^O",null,"^P",["^ ","^Q","^9","^U",17,"~:top-fn",["^ ","^10",true,"^14",2,"^11",[["^W",["~$&form","~$&env","~$args"]]],"^V",["^W",[["^1H","^1I","~$&","^1J"]]],"^13",["^W",[null]]],"^S",11,"^R",50,"~:macro",true,"^T",50,"^V",["^W",["^X",["^W",[["~$&","^1J"]]]]],"^Z","Creates a new schema.\n   ~~~klipse\n   (schema [:tuple [:int :string [:enum [:a :b :c]]]])\n   ~~~"],"^8","~$mikron.core/schema","^10",true,"^Q","mikron/core.cljc","^U",17,"^1G",["^ ","^10",true,"^14",2,"^11",[["^W",["^1H","^1I","^1J"]]],"^V",["^W",[["^1H","^1I","~$&","^1J"]]],"^13",["^W",[null]]],"^11",[["^W",["^1H","^1I","^1J"]]],"^12",null,"^13",["^W",[null]],"^S",1,"^R",50,"^1K",true,"^T",50,"^14",2,"^15",false,"^V",["^W",[["^1H","^1I","~$&","^1J"]]],"^Z","Creates a new schema.\n   ~~~klipse\n   (schema [:tuple [:int :string [:enum [:a :b :c]]]])\n   ~~~"],"~$DiffedValue",["^ ","~:num-fields",1,"~:protocols",["^7",["~$cljs.core/IRecord","~$cljs.core/IEquiv","~$cljs.core/IHash","~$cljs.core/ICollection","~$cljs.core/ICounted","~$cljs.core/ISeqable","~$cljs.core/IMeta","~$cljs.core/ICloneable","~$cljs.core/IPrintWithWriter","~$cljs.core/IIterable","~$cljs.core/IWithMeta","~$cljs.core/IAssociative","~$cljs.core/IMap","~$cljs.core/ILookup"]],"^8","~$mikron.core/DiffedValue","^Q","mikron/core.cljc","^U",23,"~:type",true,"^S",12,"~:internal-ctor",true,"^R",94,"~:record",true,"^T",94,"~:skip-protocol-flag",["^7",["^1P","^1Q","^1R","^1S","^1T","^1U","^1V","^1W","^1X","^1Z","^1[","^20","^21"]]],"^1<",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",23,"^S",17,"^T",23,"^U",27,"^1;",true,"^V",["^W",["^X",["^W",[["~$env"]]]]],"^Z","Returns all the generated processors for the given env."],"^1;",true,"^8","~$mikron.core/processors","^10",false,"^Q","mikron/core.cljc","^U",27,"^11",["^W",[["^27"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",23,"^T",23,"^14",1,"^15",true,"^V",["^W",["^X",["^W",[["^27"]]]]],"^Z","Returns all the generated processors for the given env."],"~$valid?",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",145,"^S",7,"^T",145,"^U",13,"^V",["^W",["^X",["^W",[["^17","^18"]]]]],"^Z","Returns `true` if `value` conforms to `schema`, `false` otherwise.\n   ~~~klipse\n   (let [s (schema [:vector :byte])]\n     (valid? s [0 1 2 3 4 5]))\n   ~~~"],"^8","~$mikron.core/valid?","^10",false,"^Q","mikron/core.cljc","^U",13,"^11",["^W",[["^17","^18"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",145,"^T",145,"^14",2,"^15",true,"^V",["^W",["^X",["^W",[["^17","^18"]]]]],"^Z","Returns `true` if `value` conforms to `schema`, `false` otherwise.\n   ~~~klipse\n   (let [s (schema [:vector :byte])]\n     (valid? s [0 1 2 3 4 5]))\n   ~~~"],"~$undiff",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",181,"^S",7,"^T",181,"^U",13,"^V",["^W",["^X",["^W",[["^17","^1?","^1@"]]]]],"^Z","Returns the original value from the old (`value-1`) and the diffed (`value-2`) value.\n  The old value must conform to `schema`. `value-2` must be an instance of `DiffedValue`."],"^8","~$mikron.core/undiff","^10",false,"^Q","mikron/core.cljc","^U",13,"^11",["^W",[["^17","^1?","^1@"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",181,"^T",181,"^14",3,"^15",true,"^V",["^W",["^X",["^W",[["^17","^1?","^1@"]]]]],"^Z","Returns the original value from the old (`value-1`) and the diffed (`value-2`) value.\n  The old value must conform to `schema`. `value-2` must be an instance of `DiffedValue`."],"~$set-byte-buffer-factory!",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",83,"^S",7,"^T",83,"^U",31,"^V",["^W",["^X",["^W",[["~$factory"]]]]],"^Z","Sets the byte buffer factory."],"^8","~$mikron.core/set-byte-buffer-factory!","^10",false,"^Q","mikron/core.cljc","^U",31,"^11",["^W",[["^2>"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",83,"^T",83,"^14",1,"^15",true,"^V",["^W",["^X",["^W",[["^2>"]]]]],"^Z","Sets the byte buffer factory."],"~$gen",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",134,"^S",7,"^T",134,"^U",10,"^V",["^W",["^X",["^W",[["^17"]]]]],"^Z","Generates a new value which conforms to `schema`.\n   ~~~klipse\n   (let [s (schema [:multi int? {true :int false [:enum [:a :b :c]]}])]\n     (gen s))\n   ~~~"],"^8","~$mikron.core/gen","^10",false,"^Q","mikron/core.cljc","^U",10,"^11",["^W",[["^17"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",134,"^T",134,"^14",1,"^15",true,"^V",["^W",["^X",["^W",[["^17"]]]]],"^Z","Generates a new value which conforms to `schema`.\n   ~~~klipse\n   (let [s (schema [:multi int? {true :int false [:enum [:a :b :c]]}])]\n     (gen s))\n   ~~~"],"~$diffed?",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",96,"^S",7,"^T",96,"^U",14,"^V",["^W",["^X",["^W",[["^18"]]]]],"^Z","Returns `true` if `value` is diffed, `false` otherwise."],"^8","~$mikron.core/diffed?","^10",false,"^Q","mikron/core.cljc","^U",14,"^11",["^W",[["^18"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",96,"^T",96,"^14",1,"^15",true,"^V",["^W",["^X",["^W",[["^18"]]]]],"^Z","Returns `true` if `value` is diffed, `false` otherwise."],"~$defschema",["^ ","^O",null,"^P",["^ ","^Q","^9","^U",20,"^1G",["^ ","^10",true,"^14",2,"^11",[["^W",["^1H","^1I","^1J"]]],"^V",["^W",[["^1H","^1I","~$&","^1J"]]],"^13",["^W",[null]]],"^S",11,"^R",58,"^1K",true,"^T",58,"^V",["^W",["^X",["^W",[["~$&","^1J"]]]]],"^Z","Creates a new schema and binds it to the given symbol.\n   ~~~klipse\n   (defschema my-schema\n     [:record {:a :keyword :b :ubyte}])\n   ~~~"],"^8","~$mikron.core/defschema","^10",true,"^Q","mikron/core.cljc","^U",20,"^1G",["^ ","^10",true,"^14",2,"^11",[["^W",["^1H","^1I","^1J"]]],"^V",["^W",[["^1H","^1I","~$&","^1J"]]],"^13",["^W",[null]]],"^11",[["^W",["^1H","^1I","^1J"]]],"^12",null,"^13",["^W",[null]],"^S",1,"^R",58,"^1K",true,"^T",58,"^14",2,"^15",false,"^V",["^W",[["^1H","^1I","~$&","^1J"]]],"^Z","Creates a new schema and binds it to the given symbol.\n   ~~~klipse\n   (defschema my-schema\n     [:record {:a :keyword :b :ubyte}])\n   ~~~"],"~$unpack",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",118,"^S",7,"^T",118,"^U",13,"^V",["^W",["^X",["^W",[["^17","~$binary"]]]]],"^Z","Unpacks a value (which conforms to `schema`) from the binary value `binary`.\n   ~~~klipse\n   (let [s (schema [:tuple [:int :keyword]])]\n     (->> [100 :cat] (pack s) (unpack s)))\n   ~~~"],"^8","~$mikron.core/unpack","^10",false,"^Q","mikron/core.cljc","^U",13,"^11",["^W",[["^17","^2G"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",118,"^T",118,"^14",2,"^15",true,"^V",["^W",["^X",["^W",[["^17","^2G"]]]]],"^Z","Unpacks a value (which conforms to `schema`) from the binary value `binary`.\n   ~~~klipse\n   (let [s (schema [:tuple [:int :keyword]])]\n     (->> [100 :cat] (pack s) (unpack s)))\n   ~~~"],"~$diff*",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",156,"^S",7,"^T",156,"^U",12,"^V",["^W",["^X",["^W",[["^17","^1?","^1@"]]]]],"^Z","Returns the diff between the old (`value-1`) and the new (`value-2`) value,\n  both conforming to `schema`."],"^8","~$mikron.core/diff*","^10",false,"^Q","mikron/core.cljc","^U",12,"^11",["^W",[["^17","^1?","^1@"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",156,"^T",156,"^14",3,"^15",true,"^V",["^W",["^X",["^W",[["^17","^1?","^1@"]]]]],"^Z","Returns the diff between the old (`value-1`) and the new (`value-2`) value,\n  both conforming to `schema`."],"~$->DiffedValue",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",94,"^S",12,"^T",94,"^U",23,"^24",true,"~:factory","~:positional","^V",["^W",["^X",["^W",[["^18"]]]]]],"^8","~$mikron.core/->DiffedValue","^10",false,"^Q","mikron/core.cljc","^U",23,"^11",["^W",[["^18"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^24",true,"^2L","^2M","^R",94,"^T",94,"^14",1,"^15",true,"^V",["^W",["^X",["^W",[["^18"]]]]]],"~$->Schema",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",16,"^S",12,"^T",16,"^U",18,"^24",true,"^2L","^2M","^V",["^W",["^X",["^W",[["^1<"]]]]]],"^8","~$mikron.core/->Schema","^10",false,"^Q","mikron/core.cljc","^U",18,"^11",["^W",[["^1<"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^24",true,"^2L","^2M","^R",16,"^T",16,"^14",1,"^15",true,"^V",["^W",["^X",["^W",[["^1<"]]]]]],"~$schema*",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",38,"^S",17,"^T",38,"^U",24,"^1;",true,"^V",["^W",["^X",["^W",[["^27"]]]]],"^Z","Generates all the processor related code for the given env."],"^1;",true,"^8","~$mikron.core/schema*","^10",false,"^Q","mikron/core.cljc","^U",24,"^11",["^W",[["^27"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",38,"^T",38,"^14",1,"^15",true,"^V",["^W",["^X",["^W",[["^27"]]]]],"^Z","Generates all the processor related code for the given env."],"~$schema?",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",18,"^S",7,"^T",18,"^U",14,"^V",["^W",["^X",["^W",[["^18"]]]]],"^Z","Returns `true` if `value` is an instance of `Schema`, `false` otherwise."],"^8","~$mikron.core/schema?","^10",false,"^Q","mikron/core.cljc","^U",14,"^11",["^W",[["^18"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",18,"^T",18,"^14",1,"^15",true,"^V",["^W",["^X",["^W",[["^18"]]]]],"^Z","Returns `true` if `value` is an instance of `Schema`, `false` otherwise."],"~$map->DiffedValue",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",94,"^S",12,"^T",94,"^U",23,"^24",true,"^2L","~:map","^V",["^W",["^X",["^W",[["~$G__918"]]]]]],"^8","~$mikron.core/map->DiffedValue","^10",false,"^Q","mikron/core.cljc","^U",23,"^11",["^W",[["^2W"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^24",true,"^2L","^2V","^R",94,"^T",94,"^14",1,"^15",true,"^V",["^W",["^X",["^W",[["^2W"]]]]]],"~$interp",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",189,"^S",7,"^T",189,"^U",13,"^V",["^W",["^X",["^W",[["^17","^1?","^1@","~$time-1","~$time-2","~$time"]]]]],"^Z","Calculates a new value of an entity at `time`, given two other values\n  (`value-1` and `value-2`, both conforming to `schema`) and their respective\n  timestamps (`time-1` and `time-2`). Uses linear interpolation."],"^8","~$mikron.core/interp","^10",false,"^Q","mikron/core.cljc","^U",13,"^11",["^W",[["^17","^1?","^1@","^2Z","^2[","^30"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",189,"^T",189,"^14",6,"^15",true,"^V",["^W",["^X",["^W",[["^17","^1?","^1@","^2Z","^2[","^30"]]]]],"^Z","Calculates a new value of an entity at `time`, given two other values\n  (`value-1` and `value-2`, both conforming to `schema`) and their respective\n  timestamps (`time-1` and `time-2`). Uses linear interpolation."],"~$with-buffer",["^ ","^O",null,"^P",["^ ","^Q","^9","^U",22,"^1G",["^ ","^10",true,"^14",3,"^11",[["^W",["^1H","^1I","^A","~$body"]]],"^V",["^W",[["^1H","^1I","^A","~$&","^33"]]],"^13",["^W",[null]]],"^S",11,"^R",88,"^1K",true,"^T",88,"^V",["^W",["^X",["^W",[["^A","~$&","^33"]]]]],"^Z","Executes all the expressions of `body` in the context of `buffer`."],"^8","~$mikron.core/with-buffer","^10",true,"^Q","mikron/core.cljc","^U",22,"^1G",["^ ","^10",true,"^14",3,"^11",[["^W",["^1H","^1I","^A","^33"]]],"^V",["^W",[["^1H","^1I","^A","~$&","^33"]]],"^13",["^W",[null]]],"^11",[["^W",["^1H","^1I","^A","^33"]]],"^12",null,"^13",["^W",[null]],"^S",1,"^R",88,"^1K",true,"^T",88,"^14",3,"^15",false,"^V",["^W",[["^1H","^1I","^A","~$&","^33"]]],"^Z","Executes all the expressions of `body` in the context of `buffer`."],"~$map->Schema",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",16,"^S",12,"^T",16,"^U",18,"^24",true,"^2L","^2V","^V",["^W",["^X",["^W",[["~$G__872"]]]]]],"^8","~$mikron.core/map->Schema","^10",false,"^Q","mikron/core.cljc","^U",18,"^11",["^W",[["^36"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^24",true,"^2L","^2V","^R",16,"^T",16,"^14",1,"^15",true,"^V",["^W",["^X",["^W",[["^36"]]]]]],"~$Schema",["^ ","^1N",1,"^1O",["^7",["^1P","^1Q","^1R","^1S","^1T","^1U","^1V","^1W","^1X","^1Y","^1Z","^1[","^20","^21"]],"^8","~$mikron.core/Schema","^Q","mikron/core.cljc","^U",18,"^23",true,"^S",12,"^24",true,"^R",16,"^25",true,"^T",16,"^26",["^7",["^1P","^1Q","^1R","^1S","^1T","^1U","^1V","^1W","^1X","^1Z","^1[","^20","^21"]]],"~$undiff*",["^ ","^O",null,"^P",["^ ","^Q","^9","^R",164,"^S",7,"^T",164,"^U",14,"^V",["^W",["^X",["^W",[["^17","^1?","^1@"]]]]],"^Z","Returns the original value from the old (`value-1`) and the diffed (`value-2`) value.\n  The old value must conform to `schema`."],"^8","~$mikron.core/undiff*","^10",false,"^Q","mikron/core.cljc","^U",14,"^11",["^W",[["^17","^1?","^1@"]]],"^12",null,"^13",["^W",[null,null]],"^S",1,"^R",164,"^T",164,"^14",3,"^15",true,"^V",["^W",["^X",["^W",[["^17","^1?","^1@"]]]]],"^Z","Returns the original value from the old (`value-1`) and the diffed (`value-2`) value.\n  The old value must conform to `schema`."]],"~:require-macros",["^ ","^9","^9"],"~:cljs.analyzer/constants",["^ ","~:seen",["^7",["^2P","~$&","^2R","^33","^9","~$cljs.core/binding","^2[","~:unpack-diffed","^N","^16","^1:","~:processors","~:valid?","^2N","^A","~:diffed?","^1>","^1;","~:else","^34","~:undiff","~:gen","^2G","^1B","^1J","^31","~:processor-fn","~:ns","^17","^8","^1H","^2J","^1A","^10","~:value","^2H","^3;","^Q","~$.-processors","~:unpack","^U","^1G","^19","~$mikron.core/Schema.","^1<","^29","^2;","^11","^2=","^2@","^2T","^2B","^13","~:doc-string","^2X","~:processor-type","^2D","^S","^18","^24","^36","~$cljs.core/let","^1@","^2F","^30","^2M","^1D","^2I","^2<","^2L","^2Z","^2K","^2?","~:interp","^1C","^R","^1K","^[","^27","~:mikron.spec/schema-args","^1L","~:mikron.spec/defschema-args","^2O","^1I","^2Q","^2S","~$cljs.core/fn","~:mikron/invalid","^37","^Y","^T","^2A","^1?","^2U","^2C","^14","^2>","^2:","^28","^2E","^2Y","^V","~:pack-diffed","^32","^Z","^35","^2V","~:pack","~:test","^1=","~:schema-name","~$def","~:diff","^2W","^3:"]],"~:order",["^3A","^1<","^2P","^3H","^8","^Q","^U","^S","^24","^2L","^R","^T","^V","^Z","^3W","^9","^2O","^2M","^37","^35","^2V","^36","^2T","^2S","^18","^3N","^3G","^3S","^28","^1;","^27","^3X","^1=","^1:","^3O","^3J","^3L","^2R","^2Q","^1L","^1G","^1K","^17","^10","^14","^11","^13","^1H","^1I","^1J","~$&","^3Q","^2E","^2D","^3R","^3M","^3Y","^1D","^1C","^1B","^[","^N","^Y","^2?","^2=","^2>","^34","^32","^A","^33","^3?","^3I","^2N","^2K","^2X","^2U","^2W","^2C","^2B","^3U","^3V","^19","^16","^3T","^3D","^3C","^3@","^3K","^2H","^2F","^2G","^3F","^2A","^2@","^3B","^2:","^29","^3Z","^2J","^2I","^1?","^1@","^3E","^3;","^3:","^1A","^1>","^2<","^2;","^3P","^31","^2Y","^2Z","^2[","^30"]],"^Z","Core namespace."]