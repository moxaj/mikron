["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "],"~$Object",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$mikron.core","~:imports",null,"~:requires",["^ ","~$mikron.compile-util","^<","~$mikron.util","^=","~$mikron.buffer","^>","~$mikron.codegen.gen","^?","~$mikron.codegen.validate","^@","~$buffer","^>","~$compile-util","^<","~$clojure.spec","~$cljs.spec","~$mikron.codegen.unpack","^E","~$util","^=","~$mikron.spec","^G","~$s","^D","~$mikron.util.math","^H","~$util.math","^H","~$mikron.codegen.pack","^J","~$spec","^G","~$mikron.codegen.interp","^L","^D","^D","~$mikron.codegen.diff","^M"],"~:uses",null,"~:defs",["^ ","~$allocate-buffer",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","^9","~:line",79,"~:column",7,"~:end-line",79,"~:end-column",22,"~:arglists",["~#list",["~$quote",["^Y",[["~$size"]]]]],"~:doc","Allocates a new buffer with the given `size`.\n   ~~~klipse\n   (allocate-buffer 2048)\n   ~~~"],"^8","~$mikron.core/allocate-buffer","~:variadic",false,"^S","mikron/core.cljc","^W",22,"~:method-params",["^Y",[["^["]]],"~:protocol-impl",null,"~:arglists-meta",["^Y",[null,null]],"^U",1,"^T",79,"^V",79,"~:max-fixed-arity",1,"~:fn-var",true,"^X",["^Y",["^Z",["^Y",[["^["]]]]],"^10","Allocates a new buffer with the given `size`.\n   ~~~klipse\n   (allocate-buffer 2048)\n   ~~~"],"~$pack",["^ ","^Q",null,"^R",["^ ","^S","^9","^T",111,"^U",7,"^V",111,"^W",11,"^X",["^Y",["^Z",["^Y",[["~$schema","~$value"]]]]],"^10","Packs `value`, which must conform to `schema`, and may be an instance of `DiffedValue`.\n   ~~~klipse\n   (let [my-schema (schema [:tuple [:int :keyword]])]\n     (pack my-schema [100 :cat]))\n   ~~~"],"^8","~$mikron.core/pack","^12",false,"^S","mikron/core.cljc","^W",11,"^13",["^Y",[["^19","^1:"]]],"^14",null,"^15",["^Y",[null,null]],"^U",1,"^T",111,"^V",111,"^16",2,"^17",true,"^X",["^Y",["^Z",["^Y",[["^19","^1:"]]]]],"^10","Packs `value`, which must conform to `schema`, and may be an instance of `DiffedValue`.\n   ~~~klipse\n   (let [my-schema (schema [:tuple [:int :keyword]])]\n     (pack my-schema [100 :cat]))\n   ~~~"],"~$dependencies",["^ ","^Q",null,"^R",["^ ","^S","^9","^T",31,"^U",17,"^V",31,"^W",29,"~:private",true,"^X",["^Y",["^Z",["^Y",[["~$processors"]]]]],"^10","Returns all the processor dependencies of the given processors."],"^1=",true,"^8","~$mikron.core/dependencies","^12",false,"^S","mikron/core.cljc","^W",29,"^13",["^Y",[["^1>"]]],"^14",null,"^15",["^Y",[null,null]],"^U",1,"^T",31,"^V",31,"^16",1,"^17",true,"^X",["^Y",["^Z",["^Y",[["^1>"]]]]],"^10","Returns all the processor dependencies of the given processors."],"~$diff",["^ ","^Q",null,"^R",["^ ","^S","^9","^T",191,"^U",7,"^V",191,"^W",11,"^X",["^Y",["^Z",["^Y",[["^19","~$value-1","~$value-2"]]]]],"^10","Returns the diff between the old (`value-1`) and the new (`value-2`) value, both conforming to `schema`.\n   Wraps the return value with `DiffedValue` for `pack` and `undiff` consumption.\n   ~~~klipse\n   (let [my-schema (schema [:map :byte :keyword]\n                           :diff {:all true})]\n     (diff my-schema {0 :a 1 :b} {0 :a 1 :c 2 :d}))\n   ~~~"],"^8","~$mikron.core/diff","^12",false,"^S","mikron/core.cljc","^W",11,"^13",["^Y",[["^19","^1A","^1B"]]],"^14",null,"^15",["^Y",[null,null]],"^U",1,"^T",191,"^V",191,"^16",3,"^17",true,"^X",["^Y",["^Z",["^Y",[["^19","^1A","^1B"]]]]],"^10","Returns the diff between the old (`value-1`) and the new (`value-2`) value, both conforming to `schema`.\n   Wraps the return value with `DiffedValue` for `pack` and `undiff` consumption.\n   ~~~klipse\n   (let [my-schema (schema [:map :byte :keyword]\n                           :diff {:all true})]\n     (diff my-schema {0 :a 1 :b} {0 :a 1 :c 2 :d}))\n   ~~~"],"~$*buffer*",["^ ","^R",["^ ","^S","^9","^T",75,"^U",26,"^V",75,"^W",34,"^1=",true,"~:dynamic",true],"^1=",true,"^8","~$mikron.core/*buffer*","^S","mikron/core.cljc","^W",34,"^U",1,"^1E",true,"^T",75,"^V",75,"~:tag","~$any","^10","The default buffer with 10Kb size."],"^19",["^ ","^Q",null,"^R",["^ ","^S","^9","^W",17,"~:top-fn",["^ ","^12",true,"^16",2,"^13",[["^Y",["~$&form","~$&env","~$args"]]],"^X",["^Y",[["^1J","^1K","~$&","^1L"]]],"^15",["^Y",[null]]],"^U",11,"^T",51,"~:macro",true,"^V",51,"^X",["^Y",["^Z",["^Y",[["~$&","^1L"]]]]],"^10","Creates a new schema.\n   ~~~klipse\n   (def my-schema\n     (schema [:tuple [:int :string [:enum [:a :b :c]]]]))\n   ~~~"],"^8","~$mikron.core/schema","^12",true,"^S","mikron/core.cljc","^W",17,"^1I",["^ ","^12",true,"^16",2,"^13",[["^Y",["^1J","^1K","^1L"]]],"^X",["^Y",[["^1J","^1K","~$&","^1L"]]],"^15",["^Y",[null]]],"^13",[["^Y",["^1J","^1K","^1L"]]],"^14",null,"^15",["^Y",[null]],"^U",1,"^T",51,"^1M",true,"^V",51,"^16",2,"^17",false,"^X",["^Y",[["^1J","^1K","~$&","^1L"]]],"^10","Creates a new schema.\n   ~~~klipse\n   (def my-schema\n     (schema [:tuple [:int :string [:enum [:a :b :c]]]]))\n   ~~~"],"~$DiffedValue",["^ ","~:num-fields",1,"~:protocols",["^7",["~$cljs.core/IRecord","~$cljs.core/IEquiv","~$cljs.core/IHash","~$cljs.core/ICollection","~$cljs.core/ICounted","~$cljs.core/ISeqable","~$cljs.core/IMeta","~$cljs.core/ICloneable","~$cljs.core/IPrintWithWriter","~$cljs.core/IIterable","~$cljs.core/IWithMeta","~$cljs.core/IAssociative","~$cljs.core/IMap","~$cljs.core/ILookup"]],"^8","~$mikron.core/DiffedValue","^S","mikron/core.cljc","^W",23,"~:type",true,"^U",12,"~:internal-ctor",true,"^T",104,"~:record",true,"^V",104,"~:skip-protocol-flag",["^7",["^1R","^1S","^1T","^1U","^1V","^1W","^1X","^1Y","^1Z","^20","^21","^22","^23"]]],"^1>",["^ ","^Q",null,"^R",["^ ","^S","^9","^T",24,"^U",17,"^V",24,"^W",27,"^1=",true,"^X",["^Y",["^Z",["^Y",[["~$env"]]]]],"^10","Returns all the generated processors for the given env."],"^1=",true,"^8","~$mikron.core/processors","^12",false,"^S","mikron/core.cljc","^W",27,"^13",["^Y",[["^29"]]],"^14",null,"^15",["^Y",[null,null]],"^U",1,"^T",24,"^V",24,"^16",1,"^17",true,"^X",["^Y",["^Z",["^Y",[["^29"]]]]],"^10","Returns all the generated processors for the given env."],"~$valid?",["^ ","^Q",null,"^R",["^ ","^S","^9","^T",154,"^U",7,"^V",154,"^W",13,"^X",["^Y",["^Z",["^Y",[["^19","^1:"]]]]],"^10","Returns `true` if `value` conforms to `schema`, `false` otherwise.\n   ~~~klipse\n   (let [my-schema (schema [:vector :byte])]\n     (valid? my-schema [0 1 2 3 4 5]))\n   ~~~"],"^8","~$mikron.core/valid?","^12",false,"^S","mikron/core.cljc","^W",13,"^13",["^Y",[["^19","^1:"]]],"^14",null,"^15",["^Y",[null,null]],"^U",1,"^T",154,"^V",154,"^16",2,"^17",true,"^X",["^Y",["^Z",["^Y",[["^19","^1:"]]]]],"^10","Returns `true` if `value` conforms to `schema`, `false` otherwise.\n   ~~~klipse\n   (let [my-schema (schema [:vector :byte])]\n     (valid? my-schema [0 1 2 3 4 5]))\n   ~~~"],"~$undiff",["^ ","^Q",null,"^R",["^ ","^S","^9","^T",204,"^U",7,"^V",204,"^W",13,"^X",["^Y",["^Z",["^Y",[["^19","^1A","^1B"]]]]],"^10","Returns the original value from the old (`value-1`) and the diffed (`value-2`) value. The old value must conform to\n   `schema`. `value-2` must be an instance of `DiffedValue`.\n   ~~~klipse\n   (let [my-schema (schema [:map :byte :keyword]\n                           :diff {:all true})\n         old-value {0 :a 1 :b}]\n     (->> {0 :a 1 :c 2 :d} (diff my-schema old-value) (undiff my-schema old-value)))\n   ~~~"],"^8","~$mikron.core/undiff","^12",false,"^S","mikron/core.cljc","^W",13,"^13",["^Y",[["^19","^1A","^1B"]]],"^14",null,"^15",["^Y",[null,null]],"^U",1,"^T",204,"^V",204,"^16",3,"^17",true,"^X",["^Y",["^Z",["^Y",[["^19","^1A","^1B"]]]]],"^10","Returns the original value from the old (`value-1`) and the diffed (`value-2`) value. The old value must conform to\n   `schema`. `value-2` must be an instance of `DiffedValue`.\n   ~~~klipse\n   (let [my-schema (schema [:map :byte :keyword]\n                           :diff {:all true})\n         old-value {0 :a 1 :b}]\n     (->> {0 :a 1 :c 2 :d} (diff my-schema old-value) (undiff my-schema old-value)))\n   ~~~"],"~$set-byte-buffer-factory!",["^ ","^Q",null,"^R",["^ ","^S","^9","^T",88,"^U",7,"^V",88,"^W",31,"^X",["^Y",["^Z",["^Y",[["~$factory"]]]]],"^10","Sets the byte buffer factory."],"^8","~$mikron.core/set-byte-buffer-factory!","^12",false,"^S","mikron/core.cljc","^W",31,"^13",["^Y",[["^2@"]]],"^14",null,"^15",["^Y",[null,null]],"^U",1,"^T",88,"^V",88,"^16",1,"^17",true,"^X",["^Y",["^Z",["^Y",[["^2@"]]]]],"^10","Sets the byte buffer factory."],"~$gen",["^ ","^Q",null,"^R",["^ ","^S","^9","^T",143,"^U",7,"^V",143,"^W",10,"^X",["^Y",["^Z",["^Y",[["^19"]]]]],"^10","Generates a new value which conforms to `schema`.\n   ~~~klipse\n   (let [my-schema (schema [:multi number? {true :ubyte false [:enum [:a :b :c]]}])]\n     (repeatedly 10 #(gen my-schema)))\n   ~~~"],"^8","~$mikron.core/gen","^12",false,"^S","mikron/core.cljc","^W",10,"^13",["^Y",[["^19"]]],"^14",null,"^15",["^Y",[null,null]],"^U",1,"^T",143,"^V",143,"^16",1,"^17",true,"^X",["^Y",["^Z",["^Y",[["^19"]]]]],"^10","Generates a new value which conforms to `schema`.\n   ~~~klipse\n   (let [my-schema (schema [:multi number? {true :ubyte false [:enum [:a :b :c]]}])]\n     (repeatedly 10 #(gen my-schema)))\n   ~~~"],"~$diffed?",["^ ","^Q",null,"^R",["^ ","^S","^9","^T",106,"^U",17,"^V",106,"^W",24,"^1=",true,"^X",["^Y",["^Z",["^Y",[["^1:"]]]]],"^10","Returns `true` if `value` is diffed, `false` otherwise."],"^1=",true,"^8","~$mikron.core/diffed?","^12",false,"^S","mikron/core.cljc","^W",24,"^13",["^Y",[["^1:"]]],"^14",null,"^15",["^Y",[null,null]],"^U",1,"^T",106,"^V",106,"^16",1,"^17",true,"^X",["^Y",["^Z",["^Y",[["^1:"]]]]],"^10","Returns `true` if `value` is diffed, `false` otherwise."],"~$defschema",["^ ","^Q",null,"^R",["^ ","^S","^9","^W",20,"^1I",["^ ","^12",true,"^16",2,"^13",[["^Y",["^1J","^1K","^1L"]]],"^X",["^Y",[["^1J","^1K","~$&","^1L"]]],"^15",["^Y",[null]]],"^U",11,"^T",62,"^1M",true,"^V",62,"^X",["^Y",["^Z",["^Y",[["~$&","^1L"]]]]],"^10","Creates a new schema and binds it to the given symbol.\n   ~~~klipse\n   (defschema my-schema\n     [:record {:a :keyword :b :ubyte}])\n   ~~~"],"^8","~$mikron.core/defschema","^12",true,"^S","mikron/core.cljc","^W",20,"^1I",["^ ","^12",true,"^16",2,"^13",[["^Y",["^1J","^1K","^1L"]]],"^X",["^Y",[["^1J","^1K","~$&","^1L"]]],"^15",["^Y",[null]]],"^13",[["^Y",["^1J","^1K","^1L"]]],"^14",null,"^15",["^Y",[null]],"^U",1,"^T",62,"^1M",true,"^V",62,"^16",2,"^17",false,"^X",["^Y",[["^1J","^1K","~$&","^1L"]]],"^10","Creates a new schema and binds it to the given symbol.\n   ~~~klipse\n   (defschema my-schema\n     [:record {:a :keyword :b :ubyte}])\n   ~~~"],"~$unpack",["^ ","^Q",null,"^R",["^ ","^S","^9","^T",127,"^U",7,"^V",127,"^W",13,"^X",["^Y",["^Z",["^Y",[["^19","~$binary"]]]]],"^10","Unpacks a value (which conforms to `schema`) from the binary value `binary`.\n   ~~~klipse\n   (let [my-schema (schema [:tuple [:int :keyword]])]\n     (->> [100 :cat] (pack my-schema) (unpack my-schema)))\n   ~~~"],"^8","~$mikron.core/unpack","^12",false,"^S","mikron/core.cljc","^W",13,"^13",["^Y",[["^19","^2I"]]],"^14",null,"^15",["^Y",[null,null]],"^U",1,"^T",127,"^V",127,"^16",2,"^17",true,"^X",["^Y",["^Z",["^Y",[["^19","^2I"]]]]],"^10","Unpacks a value (which conforms to `schema`) from the binary value `binary`.\n   ~~~klipse\n   (let [my-schema (schema [:tuple [:int :keyword]])]\n     (->> [100 :cat] (pack my-schema) (unpack my-schema)))\n   ~~~"],"~$diff*",["^ ","^Q",null,"^R",["^ ","^S","^9","^T",165,"^U",7,"^V",165,"^W",12,"^X",["^Y",["^Z",["^Y",[["^19","^1A","^1B"]]]]],"^10","Returns the diff between the old (`value-1`) and the new (`value-2`) value, both conforming to `schema`.\n   ~~~klipse\n   (let [my-schema (schema [:vector [:enum [:a :b]]]\n                           :diff {:all true})]\n     (diff* my-schema [:a :b :a :a] [:b :b :a :b]))\n   ~~~"],"^8","~$mikron.core/diff*","^12",false,"^S","mikron/core.cljc","^W",12,"^13",["^Y",[["^19","^1A","^1B"]]],"^14",null,"^15",["^Y",[null,null]],"^U",1,"^T",165,"^V",165,"^16",3,"^17",true,"^X",["^Y",["^Z",["^Y",[["^19","^1A","^1B"]]]]],"^10","Returns the diff between the old (`value-1`) and the new (`value-2`) value, both conforming to `schema`.\n   ~~~klipse\n   (let [my-schema (schema [:vector [:enum [:a :b]]]\n                           :diff {:all true})]\n     (diff* my-schema [:a :b :a :a] [:b :b :a :b]))\n   ~~~"],"~$->DiffedValue",["^ ","^Q",null,"^R",["^ ","^S","^9","^T",104,"^U",12,"^V",104,"^W",23,"^26",true,"~:factory","~:positional","^X",["^Y",["^Z",["^Y",[["^1:"]]]]]],"^8","~$mikron.core/->DiffedValue","^12",false,"^S","mikron/core.cljc","^W",23,"^13",["^Y",[["^1:"]]],"^14",null,"^15",["^Y",[null,null]],"^U",1,"^26",true,"^2N","^2O","^T",104,"^V",104,"^16",1,"^17",true,"^X",["^Y",["^Z",["^Y",[["^1:"]]]]]],"~$->Schema",["^ ","^Q",null,"^R",["^ ","^S","^9","^T",17,"^U",12,"^V",17,"^W",18,"^26",true,"^2N","^2O","^X",["^Y",["^Z",["^Y",[["^1>"]]]]]],"^8","~$mikron.core/->Schema","^12",false,"^S","mikron/core.cljc","^W",18,"^13",["^Y",[["^1>"]]],"^14",null,"^15",["^Y",[null,null]],"^U",1,"^26",true,"^2N","^2O","^T",17,"^V",17,"^16",1,"^17",true,"^X",["^Y",["^Z",["^Y",[["^1>"]]]]]],"~$schema*",["^ ","^Q",null,"^R",["^ ","^S","^9","^T",39,"^U",7,"^V",39,"^W",14,"^X",["^Y",["^Z",["^Y",[["~$&","^1L"]]]]],"^10","Generates all the processor related code for the given args.","^1I",["^ ","^12",true,"^16",0,"^13",[["^Y",["^1L"]]],"^X",["^Y",[["~$&","^1L"]]],"^15",["^Y",[null]]]],"^8","~$mikron.core/schema*","^12",true,"^S","mikron/core.cljc","^W",14,"^1I",["^ ","^12",true,"^16",0,"^13",[["^Y",["^1L"]]],"^X",["^Y",[["~$&","^1L"]]],"^15",["^Y",[null]]],"^13",[["^Y",["^1L"]]],"^14",null,"^15",["^Y",[null]],"^U",1,"^T",39,"^V",39,"^16",0,"^17",true,"^X",["^Y",[["~$&","^1L"]]],"^10","Generates all the processor related code for the given args."],"~$schema?",["^ ","^Q",null,"^R",["^ ","^S","^9","^T",19,"^U",7,"^V",19,"^W",14,"^X",["^Y",["^Z",["^Y",[["^1:"]]]]],"^10","Returns `true` if `value` is an instance of `Schema`, `false` otherwise."],"^8","~$mikron.core/schema?","^12",false,"^S","mikron/core.cljc","^W",14,"^13",["^Y",[["^1:"]]],"^14",null,"^15",["^Y",[null,null]],"^U",1,"^T",19,"^V",19,"^16",1,"^17",true,"^X",["^Y",["^Z",["^Y",[["^1:"]]]]],"^10","Returns `true` if `value` is an instance of `Schema`, `false` otherwise."],"~$map->DiffedValue",["^ ","^Q",null,"^R",["^ ","^S","^9","^T",104,"^U",12,"^V",104,"^W",23,"^26",true,"^2N","~:map","^X",["^Y",["^Z",["^Y",[["~$G__917"]]]]]],"^8","~$mikron.core/map->DiffedValue","^12",false,"^S","mikron/core.cljc","^W",23,"^13",["^Y",[["^2Y"]]],"^14",null,"^15",["^Y",[null,null]],"^U",1,"^26",true,"^2N","^2X","^T",104,"^V",104,"^16",1,"^17",true,"^X",["^Y",["^Z",["^Y",[["^2Y"]]]]]],"~$interp",["^ ","^Q",null,"^R",["^ ","^S","^9","^T",218,"^U",7,"^V",218,"^W",13,"^X",["^Y",["^Z",["^Y",[["^19","^1A","^1B","~$time-1","~$time-2","~$time"]]]]],"^10","Calculates a new value of an entity at `time`, given two other values (`value-1` and `value-2`, both conforming to\n   `schema`) and their respective timestamps (`time-1` and `time-2`). Uses linear interpolation.\n   ~~~klipse\n   (let [my-schema (schema [:record {:a :float :b [:vector :float]}]\n                           :interp {:a true :b {:all true}})]\n     (interp my-schema {:a 10 :b [1 2 3]} {:a 20 :b [4 5 6 7]} 0 1 0.5))\n   ~~~"],"^8","~$mikron.core/interp","^12",false,"^S","mikron/core.cljc","^W",13,"^13",["^Y",[["^19","^1A","^1B","^30","^31","^32"]]],"^14",null,"^15",["^Y",[null,null]],"^U",1,"^T",218,"^V",218,"^16",6,"^17",true,"^X",["^Y",["^Z",["^Y",[["^19","^1A","^1B","^30","^31","^32"]]]]],"^10","Calculates a new value of an entity at `time`, given two other values (`value-1` and `value-2`, both conforming to\n   `schema`) and their respective timestamps (`time-1` and `time-2`). Uses linear interpolation.\n   ~~~klipse\n   (let [my-schema (schema [:record {:a :float :b [:vector :float]}]\n                           :interp {:a true :b {:all true}})]\n     (interp my-schema {:a 10 :b [1 2 3]} {:a 20 :b [4 5 6 7]} 0 1 0.5))\n   ~~~"],"~$with-buffer",["^ ","^Q",null,"^R",["^ ","^S","^9","^W",22,"^1I",["^ ","^12",true,"^16",3,"^13",[["^Y",["^1J","^1K","^A","~$body"]]],"^X",["^Y",[["^1J","^1K","^A","~$&","^35"]]],"^15",["^Y",[null]]],"^U",11,"^T",93,"^1M",true,"^V",93,"^X",["^Y",["^Z",["^Y",[["^A","~$&","^35"]]]]],"^10","Executes all the expressions of `body` in the context of `buffer`.\n   ~~~klipse\n   (let [my-schema (schema [:list :int])]\n     (with-buffer (allocate-buffer 10000)\n       (pack my-schema (repeatedly 2000 #(rand-int 1000)))))\n   ~~~"],"^8","~$mikron.core/with-buffer","^12",true,"^S","mikron/core.cljc","^W",22,"^1I",["^ ","^12",true,"^16",3,"^13",[["^Y",["^1J","^1K","^A","^35"]]],"^X",["^Y",[["^1J","^1K","^A","~$&","^35"]]],"^15",["^Y",[null]]],"^13",[["^Y",["^1J","^1K","^A","^35"]]],"^14",null,"^15",["^Y",[null]],"^U",1,"^T",93,"^1M",true,"^V",93,"^16",3,"^17",false,"^X",["^Y",[["^1J","^1K","^A","~$&","^35"]]],"^10","Executes all the expressions of `body` in the context of `buffer`.\n   ~~~klipse\n   (let [my-schema (schema [:list :int])]\n     (with-buffer (allocate-buffer 10000)\n       (pack my-schema (repeatedly 2000 #(rand-int 1000)))))\n   ~~~"],"~$map->Schema",["^ ","^Q",null,"^R",["^ ","^S","^9","^T",17,"^U",12,"^V",17,"^W",18,"^26",true,"^2N","^2X","^X",["^Y",["^Z",["^Y",[["~$G__871"]]]]]],"^8","~$mikron.core/map->Schema","^12",false,"^S","mikron/core.cljc","^W",18,"^13",["^Y",[["^38"]]],"^14",null,"^15",["^Y",[null,null]],"^U",1,"^26",true,"^2N","^2X","^T",17,"^V",17,"^16",1,"^17",true,"^X",["^Y",["^Z",["^Y",[["^38"]]]]]],"~$Schema",["^ ","^1P",1,"^1Q",["^7",["^1R","^1S","^1T","^1U","^1V","^1W","^1X","^1Y","^1Z","^1[","^20","^21","^22","^23"]],"^8","~$mikron.core/Schema","^S","mikron/core.cljc","^W",18,"^25",true,"^U",12,"^26",true,"^T",17,"^27",true,"^V",17,"^28",["^7",["^1R","^1S","^1T","^1U","^1V","^1W","^1X","^1Y","^1Z","^20","^21","^22","^23"]]],"~$undiff*",["^ ","^Q",null,"^R",["^ ","^S","^9","^T",177,"^U",7,"^V",177,"^W",14,"^X",["^Y",["^Z",["^Y",[["^19","^1A","^1B"]]]]],"^10","Returns the original value from the old (`value-1`) and the diffed (`value-2`) value.\n   The old value must conform to `schema`.\n   ~~~klipse\n   (let [my-schema (schema [:vector [:enum [:a :b]]]\n                           :diff {:all true})\n         old-value [:a :b :a :a]]\n     (->> [:b :b :a :b] (diff* my-schema old-value) (undiff* my-schema old-value)))\n   ~~~"],"^8","~$mikron.core/undiff*","^12",false,"^S","mikron/core.cljc","^W",14,"^13",["^Y",[["^19","^1A","^1B"]]],"^14",null,"^15",["^Y",[null,null]],"^U",1,"^T",177,"^V",177,"^16",3,"^17",true,"^X",["^Y",["^Z",["^Y",[["^19","^1A","^1B"]]]]],"^10","Returns the original value from the old (`value-1`) and the diffed (`value-2`) value.\n   The old value must conform to `schema`.\n   ~~~klipse\n   (let [my-schema (schema [:vector [:enum [:a :b]]]\n                           :diff {:all true})\n         old-value [:a :b :a :a]]\n     (->> [:b :b :a :b] (diff* my-schema old-value) (undiff* my-schema old-value)))\n   ~~~"]],"~:require-macros",["^ ","^9","^9"],"~:cljs.analyzer/constants",["^ ","~:seen",["^7",["^2R","~:mikron.spec/schema*-args","~:args","~$&","^2T","^35","^9","~$cljs.core/binding","^31","~:unpack-diffed","^P","^18","^2Y","^1<","~:processors","~:valid?","^2P","^A","~:diffed?","^1@","^1=","~:else","^36","~:undiff","~:gen","^2I","^1D","^1L","~:schema*-args","^33","~:processor-fn","~:ns","^19","^8","^1J","^2L","^1C","^12","~:value","^2J","^3=","^S","~$.-processors","~:unpack","^W","^1I","^1;","~$mikron.core/Schema.","^1>","^2;","^2=","^13","^2?","^2B","^2V","^2D","^15","~:doc-string","^2Z","~:processor-type","^2F","^U","^1:","^26","~$cljs.core/let","^1B","^2H","^32","^2O","^1F","^2K","^2>","^2N","^30","^2M","^2A","~:interp","^1E","^T","^1M","^11","^29","~:mikron.spec/schema-args","^1N","~:mikron.spec/defschema-args","^2Q","^1K","^2S","^2U","~$cljs.core/fn","~:mikron/invalid","^39","^[","^V","^2C","^1A","^2W","^2E","^16","^2@","^2<","^2:","^38","^2G","^2[","^X","~:pack-diffed","^34","~$cljs.spec/fspec","^10","^37","^2X","~:pack","~:test","^1?","~:schema-name","~$def","~:diff","^3<"]],"~:order",["^3E","^1>","^2R","^3M","^8","^S","^W","^U","^26","^2N","^T","^V","^X","^10","^41","^9","^2Q","^2O","^39","^37","^2X","^38","^2V","^2U","^1:","^3S","^3L","^3X","^2:","^1=","^29","^42","^1?","^1<","^2T","^1I","^2S","^12","^16","^13","^15","^1L","~$&","^3A","^3T","^3O","^3Q","^1N","^1M","^19","^1J","^1K","^3[","^3B","^3V","^2G","^2F","^3W","^3R","^3K","^43","^1F","^1E","^1D","^11","^P","^[","^2A","^2?","^2@","^36","^34","^A","^35","^3C","^3N","^2P","^2M","^2Z","^2W","^2Y","^2E","^2D","^3Z","^40","^1;","^18","^3Y","^3H","^3G","^3D","^3P","^2J","^2H","^2I","^3J","^2C","^2B","^3F","^2<","^2;","^44","^2L","^2K","^1A","^1B","^3I","^3=","^3<","^1C","^1@","^2>","^2=","^3U","^33","^2[","^30","^31","^32"]],"^10","Core namespace."]