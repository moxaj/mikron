["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "],"~$Object",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$mikron.core$macros","~:imports",null,"~:requires",["^ ","~$mikron.compile-util","^<","~$mikron.util","^=","~$mikron.buffer","^>","~$mikron.codegen.gen","^?","~$mikron.codegen.validate","^@","~$buffer","^>","~$compile-util","^<","~$mikron.codegen.unpack","^C","~$util","^=","~$mikron.spec","^E","~$mikron.util.math","^F","~$util.math","^F","~$mikron.codegen.pack","^H","~$spec","^E","~$mikron.codegen.interp","^J","~$mikron.codegen.diff","^K"],"~:uses",null,"~:defs",["^ ","~$allocate-buffer",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","~$mikron.core","~:line",73,"~:column",7,"~:end-line",73,"~:end-column",22,"~:arglists",["~#list",["~$quote",["^X",[["~$size"]]]]],"~:doc","Allocates a new buffer with the given `size`.\n   ~~~klipse\n   (js/console.log \"b\")\n   (allocate-buffer 2048)\n   ~~~"],"^8","~$mikron.core$macros/allocate-buffer","~:variadic",false,"^Q","mikron/core.cljc","^V",22,"~:method-params",["^X",[["^Z"]]],"~:protocol-impl",null,"~:arglists-meta",["^X",[null,null]],"^T",1,"^S",73,"^U",73,"~:max-fixed-arity",1,"~:fn-var",true,"^W",["^X",["^Y",["^X",[["^Z"]]]]],"^[","Allocates a new buffer with the given `size`.\n   ~~~klipse\n   (js/console.log \"b\")\n   (allocate-buffer 2048)\n   ~~~"],"~$pack",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",101,"^T",7,"^U",101,"^V",11,"^W",["^X",["^Y",["^X",[["~$schema","~$value"]]]]],"^[","Packs `value`, which must conform to `schema`, and may be an instance of\n   `DiffedValue`.\n   ~~~klipse\n   (let [s (schema [:tuple [:int :keyword]])]\n     (pack s [100 :cat]))\n   ~~~"],"^8","~$mikron.core$macros/pack","^11",false,"^Q","mikron/core.cljc","^V",11,"^12",["^X",[["^18","^19"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",101,"^U",101,"^15",2,"^16",true,"^W",["^X",["^Y",["^X",[["^18","^19"]]]]],"^[","Packs `value`, which must conform to `schema`, and may be an instance of\n   `DiffedValue`.\n   ~~~klipse\n   (let [s (schema [:tuple [:int :keyword]])]\n     (pack s [100 :cat]))\n   ~~~"],"~$dependencies",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",30,"^T",17,"^U",30,"^V",29,"~:private",true,"^W",["^X",["^Y",["^X",[["~$processors"]]]]],"^[","Returns all the processor dependencies of the given processors."],"^1<",true,"^8","~$mikron.core$macros/dependencies","^11",false,"^Q","mikron/core.cljc","^V",29,"^12",["^X",[["^1="]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",30,"^U",30,"^15",1,"^16",true,"^W",["^X",["^Y",["^X",[["^1="]]]]],"^[","Returns all the processor dependencies of the given processors."],"~$diff",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",172,"^T",7,"^U",172,"^V",11,"^W",["^X",["^Y",["^X",[["^18","~$value-1","~$value-2"]]]]],"^[","Returns the diff between the old (`value-1`) and the new (`value-2`) value,\n  both conforming to `schema`. Wraps the return value with `DiffedValue` for `pack`\n  and `undiff` consumption."],"^8","~$mikron.core$macros/diff","^11",false,"^Q","mikron/core.cljc","^V",11,"^12",["^X",[["^18","^1@","^1A"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",172,"^U",172,"^15",3,"^16",true,"^W",["^X",["^Y",["^X",[["^18","^1@","^1A"]]]]],"^[","Returns the diff between the old (`value-1`) and the new (`value-2`) value,\n  both conforming to `schema`. Wraps the return value with `DiffedValue` for `pack`\n  and `undiff` consumption."],"~$*buffer*",["^ ","^P",["^ ","^Q","^R","^S",69,"^T",26,"^U",69,"^V",34,"^1<",true,"~:dynamic",true],"^1<",true,"^8","~$mikron.core$macros/*buffer*","^Q","mikron/core.cljc","^V",34,"^T",1,"^1D",true,"^S",69,"^U",69,"~:tag","~$any","^[","The default buffer with 10Kb size."],"^18",["^ ","^O",null,"^P",["^ ","^Q","^R","^V",17,"~:top-fn",["^ ","^11",true,"^15",2,"^12",[["^X",["~$&form","~$&env","~$args"]]],"^W",["^X",[["^1I","^1J","~$&","^1K"]]],"^14",["^X",[null]]],"^T",11,"^S",50,"~:macro",true,"^U",50,"^W",["^X",["^Y",["^X",[["~$&","^1K"]]]]],"^[","Creates a new schema.\n   ~~~klipse\n   (schema [:tuple [:int :string [:enum [:a :b :c]]]])\n   ~~~"],"^8","~$mikron.core$macros/schema","^11",true,"^Q","mikron/core.cljc","^V",17,"^1H",["^ ","^11",true,"^15",2,"^12",[["^X",["^1I","^1J","^1K"]]],"^W",["^X",[["^1I","^1J","~$&","^1K"]]],"^14",["^X",[null]]],"^12",[["^X",["^1I","^1J","^1K"]]],"^13",null,"^14",["^X",[null]],"^T",1,"^S",50,"^1L",true,"^U",50,"^15",2,"^16",false,"^W",["^X",[["^1I","^1J","~$&","^1K"]]],"^[","Creates a new schema.\n   ~~~klipse\n   (schema [:tuple [:int :string [:enum [:a :b :c]]]])\n   ~~~"],"~$DiffedValue",["^ ","~:num-fields",1,"~:protocols",["^7",["~$cljs.core/IRecord","~$cljs.core/IEquiv","~$cljs.core/IHash","~$cljs.core/ICollection","~$cljs.core/ICounted","~$cljs.core/ISeqable","~$cljs.core/IMeta","~$cljs.core/ICloneable","~$cljs.core/IPrintWithWriter","~$cljs.core/IIterable","~$cljs.core/IWithMeta","~$cljs.core/IAssociative","~$cljs.core/IMap","~$cljs.core/ILookup"]],"^8","~$mikron.core$macros/DiffedValue","^Q","mikron/core.cljc","^V",23,"~:type",true,"^T",12,"~:internal-ctor",true,"^S",94,"~:record",true,"^U",94,"~:skip-protocol-flag",["^7",["^1Q","^1R","^1S","^1T","^1U","^1V","^1W","^1X","^1Y","^1[","^20","^21","^22"]]],"^1=",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",23,"^T",17,"^U",23,"^V",27,"^1<",true,"^W",["^X",["^Y",["^X",[["~$env"]]]]],"^[","Returns all the generated processors for the given env."],"^1<",true,"^8","~$mikron.core$macros/processors","^11",false,"^Q","mikron/core.cljc","^V",27,"^12",["^X",[["^28"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",23,"^U",23,"^15",1,"^16",true,"^W",["^X",["^Y",["^X",[["^28"]]]]],"^[","Returns all the generated processors for the given env."],"~$valid?",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",145,"^T",7,"^U",145,"^V",13,"^W",["^X",["^Y",["^X",[["^18","^19"]]]]],"^[","Returns `true` if `value` conforms to `schema`, `false` otherwise.\n   ~~~klipse\n   (let [s (schema [:vector :byte])]\n     (valid? s [0 1 2 3 4 5]))\n   ~~~"],"^8","~$mikron.core$macros/valid?","^11",false,"^Q","mikron/core.cljc","^V",13,"^12",["^X",[["^18","^19"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",145,"^U",145,"^15",2,"^16",true,"^W",["^X",["^Y",["^X",[["^18","^19"]]]]],"^[","Returns `true` if `value` conforms to `schema`, `false` otherwise.\n   ~~~klipse\n   (let [s (schema [:vector :byte])]\n     (valid? s [0 1 2 3 4 5]))\n   ~~~"],"~$undiff",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",181,"^T",7,"^U",181,"^V",13,"^W",["^X",["^Y",["^X",[["^18","^1@","^1A"]]]]],"^[","Returns the original value from the old (`value-1`) and the diffed (`value-2`) value.\n  The old value must conform to `schema`. `value-2` must be an instance of `DiffedValue`."],"^8","~$mikron.core$macros/undiff","^11",false,"^Q","mikron/core.cljc","^V",13,"^12",["^X",[["^18","^1@","^1A"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",181,"^U",181,"^15",3,"^16",true,"^W",["^X",["^Y",["^X",[["^18","^1@","^1A"]]]]],"^[","Returns the original value from the old (`value-1`) and the diffed (`value-2`) value.\n  The old value must conform to `schema`. `value-2` must be an instance of `DiffedValue`."],"~$set-byte-buffer-factory!",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",83,"^T",7,"^U",83,"^V",31,"^W",["^X",["^Y",["^X",[["~$factory"]]]]],"^[","Sets the byte buffer factory."],"^8","~$mikron.core$macros/set-byte-buffer-factory!","^11",false,"^Q","mikron/core.cljc","^V",31,"^12",["^X",[["^2?"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",83,"^U",83,"^15",1,"^16",true,"^W",["^X",["^Y",["^X",[["^2?"]]]]],"^[","Sets the byte buffer factory."],"~$gen",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",134,"^T",7,"^U",134,"^V",10,"^W",["^X",["^Y",["^X",[["^18"]]]]],"^[","Generates a new value which conforms to `schema`.\n   ~~~klipse\n   (let [s (schema [:multi int? {true :int false [:enum [:a :b :c]]}])]\n     (gen s))\n   ~~~"],"^8","~$mikron.core$macros/gen","^11",false,"^Q","mikron/core.cljc","^V",10,"^12",["^X",[["^18"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",134,"^U",134,"^15",1,"^16",true,"^W",["^X",["^Y",["^X",[["^18"]]]]],"^[","Generates a new value which conforms to `schema`.\n   ~~~klipse\n   (let [s (schema [:multi int? {true :int false [:enum [:a :b :c]]}])]\n     (gen s))\n   ~~~"],"~$diffed?",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",96,"^T",7,"^U",96,"^V",14,"^W",["^X",["^Y",["^X",[["^19"]]]]],"^[","Returns `true` if `value` is diffed, `false` otherwise."],"^8","~$mikron.core$macros/diffed?","^11",false,"^Q","mikron/core.cljc","^V",14,"^12",["^X",[["^19"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",96,"^U",96,"^15",1,"^16",true,"^W",["^X",["^Y",["^X",[["^19"]]]]],"^[","Returns `true` if `value` is diffed, `false` otherwise."],"~$defschema",["^ ","^O",null,"^P",["^ ","^Q","^R","^V",20,"^1H",["^ ","^11",true,"^15",2,"^12",[["^X",["^1I","^1J","^1K"]]],"^W",["^X",[["^1I","^1J","~$&","^1K"]]],"^14",["^X",[null]]],"^T",11,"^S",58,"^1L",true,"^U",58,"^W",["^X",["^Y",["^X",[["~$&","^1K"]]]]],"^[","Creates a new schema and binds it to the given symbol.\n   ~~~klipse\n   (defschema my-schema\n     [:record {:a :keyword :b :ubyte}])\n   ~~~"],"^8","~$mikron.core$macros/defschema","^11",true,"^Q","mikron/core.cljc","^V",20,"^1H",["^ ","^11",true,"^15",2,"^12",[["^X",["^1I","^1J","^1K"]]],"^W",["^X",[["^1I","^1J","~$&","^1K"]]],"^14",["^X",[null]]],"^12",[["^X",["^1I","^1J","^1K"]]],"^13",null,"^14",["^X",[null]],"^T",1,"^S",58,"^1L",true,"^U",58,"^15",2,"^16",false,"^W",["^X",[["^1I","^1J","~$&","^1K"]]],"^[","Creates a new schema and binds it to the given symbol.\n   ~~~klipse\n   (defschema my-schema\n     [:record {:a :keyword :b :ubyte}])\n   ~~~"],"~$unpack",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",118,"^T",7,"^U",118,"^V",13,"^W",["^X",["^Y",["^X",[["^18","~$binary"]]]]],"^[","Unpacks a value (which conforms to `schema`) from the binary value `binary`.\n   ~~~klipse\n   (let [s (schema [:tuple [:int :keyword]])]\n     (->> [100 :cat] (pack s) (unpack s)))\n   ~~~"],"^8","~$mikron.core$macros/unpack","^11",false,"^Q","mikron/core.cljc","^V",13,"^12",["^X",[["^18","^2H"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",118,"^U",118,"^15",2,"^16",true,"^W",["^X",["^Y",["^X",[["^18","^2H"]]]]],"^[","Unpacks a value (which conforms to `schema`) from the binary value `binary`.\n   ~~~klipse\n   (let [s (schema [:tuple [:int :keyword]])]\n     (->> [100 :cat] (pack s) (unpack s)))\n   ~~~"],"~$diff*",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",156,"^T",7,"^U",156,"^V",12,"^W",["^X",["^Y",["^X",[["^18","^1@","^1A"]]]]],"^[","Returns the diff between the old (`value-1`) and the new (`value-2`) value,\n  both conforming to `schema`."],"^8","~$mikron.core$macros/diff*","^11",false,"^Q","mikron/core.cljc","^V",12,"^12",["^X",[["^18","^1@","^1A"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",156,"^U",156,"^15",3,"^16",true,"^W",["^X",["^Y",["^X",[["^18","^1@","^1A"]]]]],"^[","Returns the diff between the old (`value-1`) and the new (`value-2`) value,\n  both conforming to `schema`."],"~$->DiffedValue",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",94,"^T",12,"^U",94,"^V",23,"^25",true,"~:factory","~:positional","^W",["^X",["^Y",["^X",[["^19"]]]]]],"^8","~$mikron.core$macros/->DiffedValue","^11",false,"^Q","mikron/core.cljc","^V",23,"^12",["^X",[["^19"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^25",true,"^2M","^2N","^S",94,"^U",94,"^15",1,"^16",true,"^W",["^X",["^Y",["^X",[["^19"]]]]]],"~$->Schema",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",16,"^T",12,"^U",16,"^V",18,"^25",true,"^2M","^2N","^W",["^X",["^Y",["^X",[["^1="]]]]]],"^8","~$mikron.core$macros/->Schema","^11",false,"^Q","mikron/core.cljc","^V",18,"^12",["^X",[["^1="]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^25",true,"^2M","^2N","^S",16,"^U",16,"^15",1,"^16",true,"^W",["^X",["^Y",["^X",[["^1="]]]]]],"~$schema*",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",38,"^T",17,"^U",38,"^V",24,"^1<",true,"^W",["^X",["^Y",["^X",[["^28"]]]]],"^[","Generates all the processor related code for the given env."],"^1<",true,"^8","~$mikron.core$macros/schema*","^11",false,"^Q","mikron/core.cljc","^V",24,"^12",["^X",[["^28"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",38,"^U",38,"^15",1,"^16",true,"^W",["^X",["^Y",["^X",[["^28"]]]]],"^[","Generates all the processor related code for the given env."],"~$schema?",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",18,"^T",7,"^U",18,"^V",14,"^W",["^X",["^Y",["^X",[["^19"]]]]],"^[","Returns `true` if `value` is an instance of `Schema`, `false` otherwise."],"^8","~$mikron.core$macros/schema?","^11",false,"^Q","mikron/core.cljc","^V",14,"^12",["^X",[["^19"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",18,"^U",18,"^15",1,"^16",true,"^W",["^X",["^Y",["^X",[["^19"]]]]],"^[","Returns `true` if `value` is an instance of `Schema`, `false` otherwise."],"~$map->DiffedValue",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",94,"^T",12,"^U",94,"^V",23,"^25",true,"^2M","~:map","^W",["^X",["^Y",["^X",[["~$G__860"]]]]]],"^8","~$mikron.core$macros/map->DiffedValue","^11",false,"^Q","mikron/core.cljc","^V",23,"^12",["^X",[["^2X"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^25",true,"^2M","^2W","^S",94,"^U",94,"^15",1,"^16",true,"^W",["^X",["^Y",["^X",[["^2X"]]]]]],"~$interp",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",189,"^T",7,"^U",189,"^V",13,"^W",["^X",["^Y",["^X",[["^18","^1@","^1A","~$time-1","~$time-2","~$time"]]]]],"^[","Calculates a new value of an entity at `time`, given two other values\n  (`value-1` and `value-2`, both conforming to `schema`) and their respective\n  timestamps (`time-1` and `time-2`). Uses linear interpolation."],"^8","~$mikron.core$macros/interp","^11",false,"^Q","mikron/core.cljc","^V",13,"^12",["^X",[["^18","^1@","^1A","^2[","^30","^31"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",189,"^U",189,"^15",6,"^16",true,"^W",["^X",["^Y",["^X",[["^18","^1@","^1A","^2[","^30","^31"]]]]],"^[","Calculates a new value of an entity at `time`, given two other values\n  (`value-1` and `value-2`, both conforming to `schema`) and their respective\n  timestamps (`time-1` and `time-2`). Uses linear interpolation."],"~$with-buffer",["^ ","^O",null,"^P",["^ ","^Q","^R","^V",22,"^1H",["^ ","^11",true,"^15",3,"^12",[["^X",["^1I","^1J","^A","~$body"]]],"^W",["^X",[["^1I","^1J","^A","~$&","^34"]]],"^14",["^X",[null]]],"^T",11,"^S",88,"^1L",true,"^U",88,"^W",["^X",["^Y",["^X",[["^A","~$&","^34"]]]]],"^[","Executes all the expressions of `body` in the context of `buffer`."],"^8","~$mikron.core$macros/with-buffer","^11",true,"^Q","mikron/core.cljc","^V",22,"^1H",["^ ","^11",true,"^15",3,"^12",[["^X",["^1I","^1J","^A","^34"]]],"^W",["^X",[["^1I","^1J","^A","~$&","^34"]]],"^14",["^X",[null]]],"^12",[["^X",["^1I","^1J","^A","^34"]]],"^13",null,"^14",["^X",[null]],"^T",1,"^S",88,"^1L",true,"^U",88,"^15",3,"^16",false,"^W",["^X",[["^1I","^1J","^A","~$&","^34"]]],"^[","Executes all the expressions of `body` in the context of `buffer`."],"~$map->Schema",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",16,"^T",12,"^U",16,"^V",18,"^25",true,"^2M","^2W","^W",["^X",["^Y",["^X",[["~$G__814"]]]]]],"^8","~$mikron.core$macros/map->Schema","^11",false,"^Q","mikron/core.cljc","^V",18,"^12",["^X",[["^37"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^25",true,"^2M","^2W","^S",16,"^U",16,"^15",1,"^16",true,"^W",["^X",["^Y",["^X",[["^37"]]]]]],"~$Schema",["^ ","^1O",1,"^1P",["^7",["^1Q","^1R","^1S","^1T","^1U","^1V","^1W","^1X","^1Y","^1Z","^1[","^20","^21","^22"]],"^8","~$mikron.core$macros/Schema","^Q","mikron/core.cljc","^V",18,"^24",true,"^T",12,"^25",true,"^S",16,"^26",true,"^U",16,"^27",["^7",["^1Q","^1R","^1S","^1T","^1U","^1V","^1W","^1X","^1Y","^1[","^20","^21","^22"]]],"~$undiff*",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",164,"^T",7,"^U",164,"^V",14,"^W",["^X",["^Y",["^X",[["^18","^1@","^1A"]]]]],"^[","Returns the original value from the old (`value-1`) and the diffed (`value-2`) value.\n  The old value must conform to `schema`."],"^8","~$mikron.core$macros/undiff*","^11",false,"^Q","mikron/core.cljc","^V",14,"^12",["^X",[["^18","^1@","^1A"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",164,"^U",164,"^15",3,"^16",true,"^W",["^X",["^Y",["^X",[["^18","^1@","^1A"]]]]],"^[","Returns the original value from the old (`value-1`) and the diffed (`value-2`) value.\n  The old value must conform to `schema`."]],"~:require-macros",["^ ","^B","^<","^<","^<","^D","^=","^=","^="],"~:cljs.analyzer/constants",["^ ","~:seen",["^7",["~$&","^34","~$cljs.core/binding","^30","~:unpack-diffed","^10","^N","^17","^1:","^9","^1;","^1>","~:processors","~:valid?","^A","~:diffed?","^1B","^1?","^1<","~:else","~:undiff","~:gen","^2X","^2H","^1C","^1E","^1K","~:processor-fn","~:ns","^18","^1M","^8","^1I","^11","~:value","^Q","~$.-processors","~:unpack","^V","^1H","~$mikron.core/Schema.","^2;","^29","^1=","^2:","^2=","^2<","^12","^2@","^2>","^2A","^2B","^2C","^2D","^14","~:doc-string","~:processor-type","^2F","^2E","^T","^19","^25","~$cljs.core/let","^1A","^2I","^2G","^31","^2N","~$mikron.core/*buffer*","^2J","^2K","^2M","^2[","^2L","^2O","~:interp","^1D","^S","^1L","^28","~:mikron.spec/schema-args","~:mikron.spec/defschema-args","^2P","^2Q","^1J","^2R","^2S","^2T","^2U","~$cljs.core/fn","~:mikron/invalid","^Z","^U","^37","^1@","^2Y","^2V","^15","^2?","^2Z","^32","^W","~:pack-diffed","^35","^33","^[","^38","^36","^2W","~:pack","~:test","~:schema-name","~$def","~:diff","^3<","^3;"]],"~:order",["^3B","^1=","^2Q","^3I","^8","^Q","^V","^T","^25","^2M","^S","^U","^W","^[","^3Y","^9","^2P","^2N","^38","^36","^2W","^37","^2U","^2T","^19","^3O","^3H","^3U","^29","^1<","^28","^3Z","^1>","^1;","^3P","^3K","^3M","^2S","^2R","^1M","^1H","^1L","^18","^11","^15","^12","^14","^1I","^1J","^1K","~$&","^3S","^2F","^2E","^3T","^3N","^3[","^1E","^1D","^1C","^10","^N","^Z","^2@","^2>","^2?","^35","^33","^A","^34","^3@","^3Q","^3J","^2O","^2L","^2Y","^2V","^2X","^2D","^2C","^3W","^3X","^1:","^17","^3V","^3E","^3D","^3A","^3L","^2I","^2G","^2H","^3G","^2B","^2A","^3C","^2;","^2:","^40","^2K","^2J","^1@","^1A","^3F","^3<","^3;","^1B","^1?","^2=","^2<","^3R","^32","^2Z","^2[","^30","^31"]],"^[","Core namespace."]