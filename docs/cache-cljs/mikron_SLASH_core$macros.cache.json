["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "],"~$Object",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$mikron.core$macros","~:imports",null,"~:requires",["^ ","~$mikron.compile-util","^<","~$mikron.util","^=","~$mikron.buffer","^>","~$mikron.codegen.gen","^?","~$mikron.codegen.validate","^@","~$buffer","^>","~$compile-util","^<","~$mikron.codegen.unpack","^C","~$util","^=","~$mikron.spec","^E","~$mikron.util.math","^F","~$util.math","^F","~$mikron.codegen.pack","^H","~$spec","^E","~$mikron.codegen.interp","^J","~$mikron.codegen.diff","^K"],"~:uses",null,"~:defs",["^ ","~$allocate-buffer",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","~$mikron.core","~:line",74,"~:column",7,"~:end-line",74,"~:end-column",22,"~:arglists",["~#list",["~$quote",["^X",[["~$size"]]]]],"~:doc","Allocates a new buffer with the given `size`.\n   ~~~klipse\n   (allocate-buffer 2048)\n   ~~~"],"^8","~$mikron.core$macros/allocate-buffer","~:variadic",false,"^Q","mikron/core.cljc","^V",22,"~:method-params",["^X",[["^Z"]]],"~:protocol-impl",null,"~:arglists-meta",["^X",[null,null]],"^T",1,"^S",74,"^U",74,"~:max-fixed-arity",1,"~:fn-var",true,"^W",["^X",["^Y",["^X",[["^Z"]]]]],"^[","Allocates a new buffer with the given `size`.\n   ~~~klipse\n   (allocate-buffer 2048)\n   ~~~"],"~$pack",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",106,"^T",7,"^U",106,"^V",11,"^W",["^X",["^Y",["^X",[["~$schema","~$value"]]]]],"^[","Packs `value`, which must conform to `schema`, and may be an instance of `DiffedValue`.\n   ~~~klipse\n   (let [my-schema (schema [:tuple [:int :keyword]])]\n     (pack my-schema [100 :cat]))\n   ~~~"],"^8","~$mikron.core$macros/pack","^11",false,"^Q","mikron/core.cljc","^V",11,"^12",["^X",[["^18","^19"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",106,"^U",106,"^15",2,"^16",true,"^W",["^X",["^Y",["^X",[["^18","^19"]]]]],"^[","Packs `value`, which must conform to `schema`, and may be an instance of `DiffedValue`.\n   ~~~klipse\n   (let [my-schema (schema [:tuple [:int :keyword]])]\n     (pack my-schema [100 :cat]))\n   ~~~"],"~$dependencies",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",30,"^T",17,"^U",30,"^V",29,"~:private",true,"^W",["^X",["^Y",["^X",[["~$processors"]]]]],"^[","Returns all the processor dependencies of the given processors."],"^1<",true,"^8","~$mikron.core$macros/dependencies","^11",false,"^Q","mikron/core.cljc","^V",29,"^12",["^X",[["^1="]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",30,"^U",30,"^15",1,"^16",true,"^W",["^X",["^Y",["^X",[["^1="]]]]],"^[","Returns all the processor dependencies of the given processors."],"~$diff",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",186,"^T",7,"^U",186,"^V",11,"^W",["^X",["^Y",["^X",[["^18","~$value-1","~$value-2"]]]]],"^[","Returns the diff between the old (`value-1`) and the new (`value-2`) value, both conforming to `schema`.\n   Wraps the return value with `DiffedValue` for `pack` and `undiff` consumption.\n   ~~~klipse\n   (let [my-schema (schema [:map :byte :keyword]\n                           :diff {:all true})]\n     (diff my-schema {0 :a 1 :b} {0 :a 1 :c 2 :d}))\n   ~~~"],"^8","~$mikron.core$macros/diff","^11",false,"^Q","mikron/core.cljc","^V",11,"^12",["^X",[["^18","^1@","^1A"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",186,"^U",186,"^15",3,"^16",true,"^W",["^X",["^Y",["^X",[["^18","^1@","^1A"]]]]],"^[","Returns the diff between the old (`value-1`) and the new (`value-2`) value, both conforming to `schema`.\n   Wraps the return value with `DiffedValue` for `pack` and `undiff` consumption.\n   ~~~klipse\n   (let [my-schema (schema [:map :byte :keyword]\n                           :diff {:all true})]\n     (diff my-schema {0 :a 1 :b} {0 :a 1 :c 2 :d}))\n   ~~~"],"~$*buffer*",["^ ","^P",["^ ","^Q","^R","^S",70,"^T",26,"^U",70,"^V",34,"^1<",true,"~:dynamic",true],"^1<",true,"^8","~$mikron.core$macros/*buffer*","^Q","mikron/core.cljc","^V",34,"^T",1,"^1D",true,"^S",70,"^U",70,"~:tag","~$any","^[","The default buffer with 10Kb size."],"^18",["^ ","^O",null,"^P",["^ ","^Q","^R","^V",17,"~:top-fn",["^ ","^11",true,"^15",2,"^12",[["^X",["~$&form","~$&env","~$args"]]],"^W",["^X",[["^1I","^1J","~$&","^1K"]]],"^14",["^X",[null]]],"^T",11,"^S",50,"~:macro",true,"^U",50,"^W",["^X",["^Y",["^X",[["~$&","^1K"]]]]],"^[","Creates a new schema.\n   ~~~klipse\n   (def my-schema\n     (schema [:tuple [:int :string [:enum [:a :b :c]]]]))\n   ~~~"],"^8","~$mikron.core$macros/schema","^11",true,"^Q","mikron/core.cljc","^V",17,"^1H",["^ ","^11",true,"^15",2,"^12",[["^X",["^1I","^1J","^1K"]]],"^W",["^X",[["^1I","^1J","~$&","^1K"]]],"^14",["^X",[null]]],"^12",[["^X",["^1I","^1J","^1K"]]],"^13",null,"^14",["^X",[null]],"^T",1,"^S",50,"^1L",true,"^U",50,"^15",2,"^16",false,"^W",["^X",[["^1I","^1J","~$&","^1K"]]],"^[","Creates a new schema.\n   ~~~klipse\n   (def my-schema\n     (schema [:tuple [:int :string [:enum [:a :b :c]]]]))\n   ~~~"],"~$DiffedValue",["^ ","~:num-fields",1,"~:protocols",["^7",["~$cljs.core/IRecord","~$cljs.core/IEquiv","~$cljs.core/IHash","~$cljs.core/ICollection","~$cljs.core/ICounted","~$cljs.core/ISeqable","~$cljs.core/IMeta","~$cljs.core/ICloneable","~$cljs.core/IPrintWithWriter","~$cljs.core/IIterable","~$cljs.core/IWithMeta","~$cljs.core/IAssociative","~$cljs.core/IMap","~$cljs.core/ILookup"]],"^8","~$mikron.core$macros/DiffedValue","^Q","mikron/core.cljc","^V",23,"~:type",true,"^T",12,"~:internal-ctor",true,"^S",99,"~:record",true,"^U",99,"~:skip-protocol-flag",["^7",["^1Q","^1R","^1S","^1T","^1U","^1V","^1W","^1X","^1Y","^1[","^20","^21","^22"]]],"^1=",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",23,"^T",17,"^U",23,"^V",27,"^1<",true,"^W",["^X",["^Y",["^X",[["~$env"]]]]],"^[","Returns all the generated processors for the given env."],"^1<",true,"^8","~$mikron.core$macros/processors","^11",false,"^Q","mikron/core.cljc","^V",27,"^12",["^X",[["^28"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",23,"^U",23,"^15",1,"^16",true,"^W",["^X",["^Y",["^X",[["^28"]]]]],"^[","Returns all the generated processors for the given env."],"~$valid?",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",149,"^T",7,"^U",149,"^V",13,"^W",["^X",["^Y",["^X",[["^18","^19"]]]]],"^[","Returns `true` if `value` conforms to `schema`, `false` otherwise.\n   ~~~klipse\n   (let [my-schema (schema [:vector :byte])]\n     (valid? my-schema [0 1 2 3 4 5]))\n   ~~~"],"^8","~$mikron.core$macros/valid?","^11",false,"^Q","mikron/core.cljc","^V",13,"^12",["^X",[["^18","^19"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",149,"^U",149,"^15",2,"^16",true,"^W",["^X",["^Y",["^X",[["^18","^19"]]]]],"^[","Returns `true` if `value` conforms to `schema`, `false` otherwise.\n   ~~~klipse\n   (let [my-schema (schema [:vector :byte])]\n     (valid? my-schema [0 1 2 3 4 5]))\n   ~~~"],"~$undiff",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",199,"^T",7,"^U",199,"^V",13,"^W",["^X",["^Y",["^X",[["^18","^1@","^1A"]]]]],"^[","Returns the original value from the old (`value-1`) and the diffed (`value-2`) value. The old value must conform to\n   `schema`. `value-2` must be an instance of `DiffedValue`.\n   ~~~klipse\n   (let [my-schema (schema [:map :byte :keyword]\n                           :diff {:all true})\n         old-value {0 :a 1 :b}]\n     (->> {0 :a 1 :c 2 :d} (diff my-schema old-value) (undiff my-schema old-value)))\n   ~~~"],"^8","~$mikron.core$macros/undiff","^11",false,"^Q","mikron/core.cljc","^V",13,"^12",["^X",[["^18","^1@","^1A"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",199,"^U",199,"^15",3,"^16",true,"^W",["^X",["^Y",["^X",[["^18","^1@","^1A"]]]]],"^[","Returns the original value from the old (`value-1`) and the diffed (`value-2`) value. The old value must conform to\n   `schema`. `value-2` must be an instance of `DiffedValue`.\n   ~~~klipse\n   (let [my-schema (schema [:map :byte :keyword]\n                           :diff {:all true})\n         old-value {0 :a 1 :b}]\n     (->> {0 :a 1 :c 2 :d} (diff my-schema old-value) (undiff my-schema old-value)))\n   ~~~"],"~$set-byte-buffer-factory!",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",83,"^T",7,"^U",83,"^V",31,"^W",["^X",["^Y",["^X",[["~$factory"]]]]],"^[","Sets the byte buffer factory."],"^8","~$mikron.core$macros/set-byte-buffer-factory!","^11",false,"^Q","mikron/core.cljc","^V",31,"^12",["^X",[["^2?"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",83,"^U",83,"^15",1,"^16",true,"^W",["^X",["^Y",["^X",[["^2?"]]]]],"^[","Sets the byte buffer factory."],"~$gen",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",138,"^T",7,"^U",138,"^V",10,"^W",["^X",["^Y",["^X",[["^18"]]]]],"^[","Generates a new value which conforms to `schema`.\n   ~~~klipse\n   (let [my-schema (schema [:multi number? {true :ubyte false [:enum [:a :b :c]]}])]\n     (repeatedly 10 #(gen my-schema)))\n   ~~~"],"^8","~$mikron.core$macros/gen","^11",false,"^Q","mikron/core.cljc","^V",10,"^12",["^X",[["^18"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",138,"^U",138,"^15",1,"^16",true,"^W",["^X",["^Y",["^X",[["^18"]]]]],"^[","Generates a new value which conforms to `schema`.\n   ~~~klipse\n   (let [my-schema (schema [:multi number? {true :ubyte false [:enum [:a :b :c]]}])]\n     (repeatedly 10 #(gen my-schema)))\n   ~~~"],"~$diffed?",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",101,"^T",17,"^U",101,"^V",24,"^1<",true,"^W",["^X",["^Y",["^X",[["^19"]]]]],"^[","Returns `true` if `value` is diffed, `false` otherwise."],"^1<",true,"^8","~$mikron.core$macros/diffed?","^11",false,"^Q","mikron/core.cljc","^V",24,"^12",["^X",[["^19"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",101,"^U",101,"^15",1,"^16",true,"^W",["^X",["^Y",["^X",[["^19"]]]]],"^[","Returns `true` if `value` is diffed, `false` otherwise."],"~$defschema",["^ ","^O",null,"^P",["^ ","^Q","^R","^V",20,"^1H",["^ ","^11",true,"^15",2,"^12",[["^X",["^1I","^1J","^1K"]]],"^W",["^X",[["^1I","^1J","~$&","^1K"]]],"^14",["^X",[null]]],"^T",11,"^S",59,"^1L",true,"^U",59,"^W",["^X",["^Y",["^X",[["~$&","^1K"]]]]],"^[","Creates a new schema and binds it to the given symbol.\n   ~~~klipse\n   (defschema my-schema\n     [:record {:a :keyword :b :ubyte}])\n   ~~~"],"^8","~$mikron.core$macros/defschema","^11",true,"^Q","mikron/core.cljc","^V",20,"^1H",["^ ","^11",true,"^15",2,"^12",[["^X",["^1I","^1J","^1K"]]],"^W",["^X",[["^1I","^1J","~$&","^1K"]]],"^14",["^X",[null]]],"^12",[["^X",["^1I","^1J","^1K"]]],"^13",null,"^14",["^X",[null]],"^T",1,"^S",59,"^1L",true,"^U",59,"^15",2,"^16",false,"^W",["^X",[["^1I","^1J","~$&","^1K"]]],"^[","Creates a new schema and binds it to the given symbol.\n   ~~~klipse\n   (defschema my-schema\n     [:record {:a :keyword :b :ubyte}])\n   ~~~"],"~$unpack",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",122,"^T",7,"^U",122,"^V",13,"^W",["^X",["^Y",["^X",[["^18","~$binary"]]]]],"^[","Unpacks a value (which conforms to `schema`) from the binary value `binary`.\n   ~~~klipse\n   (let [my-schema (schema [:tuple [:int :keyword]])]\n     (->> [100 :cat] (pack my-schema) (unpack my-schema)))\n   ~~~"],"^8","~$mikron.core$macros/unpack","^11",false,"^Q","mikron/core.cljc","^V",13,"^12",["^X",[["^18","^2H"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",122,"^U",122,"^15",2,"^16",true,"^W",["^X",["^Y",["^X",[["^18","^2H"]]]]],"^[","Unpacks a value (which conforms to `schema`) from the binary value `binary`.\n   ~~~klipse\n   (let [my-schema (schema [:tuple [:int :keyword]])]\n     (->> [100 :cat] (pack my-schema) (unpack my-schema)))\n   ~~~"],"~$diff*",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",160,"^T",7,"^U",160,"^V",12,"^W",["^X",["^Y",["^X",[["^18","^1@","^1A"]]]]],"^[","Returns the diff between the old (`value-1`) and the new (`value-2`) value, both conforming to `schema`.\n   ~~~klipse\n   (let [my-schema (schema [:vector [:enum [:a :b]]]\n                           :diff {:all true})]\n     (diff* my-schema [:a :b :a :a] [:b :b :a :b]))\n   ~~~"],"^8","~$mikron.core$macros/diff*","^11",false,"^Q","mikron/core.cljc","^V",12,"^12",["^X",[["^18","^1@","^1A"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",160,"^U",160,"^15",3,"^16",true,"^W",["^X",["^Y",["^X",[["^18","^1@","^1A"]]]]],"^[","Returns the diff between the old (`value-1`) and the new (`value-2`) value, both conforming to `schema`.\n   ~~~klipse\n   (let [my-schema (schema [:vector [:enum [:a :b]]]\n                           :diff {:all true})]\n     (diff* my-schema [:a :b :a :a] [:b :b :a :b]))\n   ~~~"],"~$->DiffedValue",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",99,"^T",12,"^U",99,"^V",23,"^25",true,"~:factory","~:positional","^W",["^X",["^Y",["^X",[["^19"]]]]]],"^8","~$mikron.core$macros/->DiffedValue","^11",false,"^Q","mikron/core.cljc","^V",23,"^12",["^X",[["^19"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^25",true,"^2M","^2N","^S",99,"^U",99,"^15",1,"^16",true,"^W",["^X",["^Y",["^X",[["^19"]]]]]],"~$->Schema",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",16,"^T",12,"^U",16,"^V",18,"^25",true,"^2M","^2N","^W",["^X",["^Y",["^X",[["^1="]]]]]],"^8","~$mikron.core$macros/->Schema","^11",false,"^Q","mikron/core.cljc","^V",18,"^12",["^X",[["^1="]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^25",true,"^2M","^2N","^S",16,"^U",16,"^15",1,"^16",true,"^W",["^X",["^Y",["^X",[["^1="]]]]]],"~$schema*",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",38,"^T",17,"^U",38,"^V",24,"^1<",true,"^W",["^X",["^Y",["^X",[["^28"]]]]],"^[","Generates all the processor related code for the given env."],"^1<",true,"^8","~$mikron.core$macros/schema*","^11",false,"^Q","mikron/core.cljc","^V",24,"^12",["^X",[["^28"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",38,"^U",38,"^15",1,"^16",true,"^W",["^X",["^Y",["^X",[["^28"]]]]],"^[","Generates all the processor related code for the given env."],"~$schema?",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",18,"^T",7,"^U",18,"^V",14,"^W",["^X",["^Y",["^X",[["^19"]]]]],"^[","Returns `true` if `value` is an instance of `Schema`, `false` otherwise."],"^8","~$mikron.core$macros/schema?","^11",false,"^Q","mikron/core.cljc","^V",14,"^12",["^X",[["^19"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",18,"^U",18,"^15",1,"^16",true,"^W",["^X",["^Y",["^X",[["^19"]]]]],"^[","Returns `true` if `value` is an instance of `Schema`, `false` otherwise."],"~$map->DiffedValue",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",99,"^T",12,"^U",99,"^V",23,"^25",true,"^2M","~:map","^W",["^X",["^Y",["^X",[["~$G__860"]]]]]],"^8","~$mikron.core$macros/map->DiffedValue","^11",false,"^Q","mikron/core.cljc","^V",23,"^12",["^X",[["^2X"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^25",true,"^2M","^2W","^S",99,"^U",99,"^15",1,"^16",true,"^W",["^X",["^Y",["^X",[["^2X"]]]]]],"~$interp",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",213,"^T",7,"^U",213,"^V",13,"^W",["^X",["^Y",["^X",[["^18","^1@","^1A","~$time-1","~$time-2","~$time"]]]]],"^[","Calculates a new value of an entity at `time`, given two other values (`value-1` and `value-2`, both conforming to\n   `schema`) and their respective timestamps (`time-1` and `time-2`). Uses linear interpolation.\n   ~~~klipse\n   (let [my-schema (schema [:record {:a :float :b [:vector :float]}]\n                           :interp {:a true :b {:all true}})]\n     (interp my-schema {:a 10 :b [1 2 3]} {:a 20 :b [4 5 6 7]} 0 1 0.5))\n   ~~~"],"^8","~$mikron.core$macros/interp","^11",false,"^Q","mikron/core.cljc","^V",13,"^12",["^X",[["^18","^1@","^1A","^2[","^30","^31"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",213,"^U",213,"^15",6,"^16",true,"^W",["^X",["^Y",["^X",[["^18","^1@","^1A","^2[","^30","^31"]]]]],"^[","Calculates a new value of an entity at `time`, given two other values (`value-1` and `value-2`, both conforming to\n   `schema`) and their respective timestamps (`time-1` and `time-2`). Uses linear interpolation.\n   ~~~klipse\n   (let [my-schema (schema [:record {:a :float :b [:vector :float]}]\n                           :interp {:a true :b {:all true}})]\n     (interp my-schema {:a 10 :b [1 2 3]} {:a 20 :b [4 5 6 7]} 0 1 0.5))\n   ~~~"],"~$with-buffer",["^ ","^O",null,"^P",["^ ","^Q","^R","^V",22,"^1H",["^ ","^11",true,"^15",3,"^12",[["^X",["^1I","^1J","^A","~$body"]]],"^W",["^X",[["^1I","^1J","^A","~$&","^34"]]],"^14",["^X",[null]]],"^T",11,"^S",88,"^1L",true,"^U",88,"^W",["^X",["^Y",["^X",[["^A","~$&","^34"]]]]],"^[","Executes all the expressions of `body` in the context of `buffer`.\n   ~~~klipse\n   (let [my-schema (schema [:list :int])]\n     (with-buffer (allocate-buffer 10000)\n       (pack my-schema (repeatedly 2000 #(rand-int 1000)))))\n   ~~~"],"^8","~$mikron.core$macros/with-buffer","^11",true,"^Q","mikron/core.cljc","^V",22,"^1H",["^ ","^11",true,"^15",3,"^12",[["^X",["^1I","^1J","^A","^34"]]],"^W",["^X",[["^1I","^1J","^A","~$&","^34"]]],"^14",["^X",[null]]],"^12",[["^X",["^1I","^1J","^A","^34"]]],"^13",null,"^14",["^X",[null]],"^T",1,"^S",88,"^1L",true,"^U",88,"^15",3,"^16",false,"^W",["^X",[["^1I","^1J","^A","~$&","^34"]]],"^[","Executes all the expressions of `body` in the context of `buffer`.\n   ~~~klipse\n   (let [my-schema (schema [:list :int])]\n     (with-buffer (allocate-buffer 10000)\n       (pack my-schema (repeatedly 2000 #(rand-int 1000)))))\n   ~~~"],"~$map->Schema",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",16,"^T",12,"^U",16,"^V",18,"^25",true,"^2M","^2W","^W",["^X",["^Y",["^X",[["~$G__814"]]]]]],"^8","~$mikron.core$macros/map->Schema","^11",false,"^Q","mikron/core.cljc","^V",18,"^12",["^X",[["^37"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^25",true,"^2M","^2W","^S",16,"^U",16,"^15",1,"^16",true,"^W",["^X",["^Y",["^X",[["^37"]]]]]],"~$Schema",["^ ","^1O",1,"^1P",["^7",["^1Q","^1R","^1S","^1T","^1U","^1V","^1W","^1X","^1Y","^1Z","^1[","^20","^21","^22"]],"^8","~$mikron.core$macros/Schema","^Q","mikron/core.cljc","^V",18,"^24",true,"^T",12,"^25",true,"^S",16,"^26",true,"^U",16,"^27",["^7",["^1Q","^1R","^1S","^1T","^1U","^1V","^1W","^1X","^1Y","^1[","^20","^21","^22"]]],"~$undiff*",["^ ","^O",null,"^P",["^ ","^Q","^R","^S",172,"^T",7,"^U",172,"^V",14,"^W",["^X",["^Y",["^X",[["^18","^1@","^1A"]]]]],"^[","Returns the original value from the old (`value-1`) and the diffed (`value-2`) value.\n   The old value must conform to `schema`.\n   ~~~klipse\n   (let [my-schema (schema [:vector [:enum [:a :b]]]\n                           :diff {:all true})\n         old-value [:a :b :a :a]]\n     (->> [:b :b :a :b] (diff* my-schema old-value) (undiff* my-schema old-value)))\n   ~~~"],"^8","~$mikron.core$macros/undiff*","^11",false,"^Q","mikron/core.cljc","^V",14,"^12",["^X",[["^18","^1@","^1A"]]],"^13",null,"^14",["^X",[null,null]],"^T",1,"^S",172,"^U",172,"^15",3,"^16",true,"^W",["^X",["^Y",["^X",[["^18","^1@","^1A"]]]]],"^[","Returns the original value from the old (`value-1`) and the diffed (`value-2`) value.\n   The old value must conform to `schema`.\n   ~~~klipse\n   (let [my-schema (schema [:vector [:enum [:a :b]]]\n                           :diff {:all true})\n         old-value [:a :b :a :a]]\n     (->> [:b :b :a :b] (diff* my-schema old-value) (undiff* my-schema old-value)))\n   ~~~"]],"~:require-macros",["^ ","^B","^<","^<","^<","^D","^=","^=","^="],"~:cljs.analyzer/constants",["^ ","~:seen",["^7",["~$&","^34","~$cljs.core/binding","^30","~:unpack-diffed","^10","^N","^17","^1:","^9","^1;","^1>","~:processors","~:valid?","^A","~:diffed?","^1B","^1?","^1<","~:else","~:undiff","~:gen","^2X","^2H","^1C","^1E","^1K","~:processor-fn","~:ns","^18","^1M","^8","^1I","^11","~:value","^Q","~$.-processors","~:unpack","^V","^1H","~$mikron.core/Schema.","^2;","^29","^1=","^2:","^2=","^2<","^12","^2@","^2>","^2A","^2B","^2C","^2D","^14","~:doc-string","~:processor-type","^2F","^2E","^T","^19","^25","~$cljs.core/let","^1A","^2I","^2G","^31","^2N","~$mikron.core/*buffer*","^2J","^2K","^2M","^2[","^2L","^2O","~:interp","^1D","^S","^1L","^28","~:mikron.spec/schema-args","~:mikron.spec/defschema-args","^2P","^2Q","^1J","^2R","^2S","^2T","^2U","~$cljs.core/fn","~:mikron/invalid","^Z","^U","^37","^1@","^2Y","^2V","^15","^2?","^2Z","^32","^W","~:pack-diffed","^35","^33","^[","^38","^36","^2W","~:pack","~:test","~:schema-name","~$def","~:diff","^3<","^3;"]],"~:order",["^3B","^1=","^2Q","^3I","^8","^Q","^V","^T","^25","^2M","^S","^U","^W","^[","^3Y","^9","^2P","^2N","^38","^36","^2W","^37","^2U","^2T","^19","^3O","^3H","^3U","^29","^1<","^28","^3Z","^1>","^1;","^3P","^3K","^3M","^2S","^2R","^1M","^1H","^1L","^18","^11","^15","^12","^14","^1I","^1J","^1K","~$&","^3S","^2F","^2E","^3T","^3N","^3[","^1E","^1D","^1C","^10","^N","^Z","^2@","^2>","^2?","^35","^33","^A","^34","^3@","^3Q","^3J","^2O","^2L","^2Y","^2V","^2X","^2D","^2C","^3W","^3X","^1:","^17","^3V","^3E","^3D","^3A","^3L","^2I","^2G","^2H","^3G","^2B","^2A","^3C","^2;","^2:","^40","^2K","^2J","^1@","^1A","^3F","^3<","^3;","^1B","^1?","^2=","^2<","^3R","^32","^2Z","^2[","^30","^31"]],"^[","Core namespace."]