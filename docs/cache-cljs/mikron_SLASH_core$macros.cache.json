["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "],"~$Object",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$mikron.core$macros","~:imports",null,"~:requires",["^ ","~$mikron.compile-util","^<","~$mikron.util","^=","~$mikron.buffer","^>","~$mikron.codegen.gen","^?","~$mikron.codegen.validate","^@","~$buffer","^>","~$compile-util","^<","~$clojure.spec","~$cljs.spec","~$mikron.codegen.unpack","^E","~$util","^=","~$mikron.spec","^G","~$s","^D","~$mikron.util.math","^H","~$util.math","^H","~$mikron.codegen.pack","^J","~$spec","^G","~$mikron.codegen.interp","^L","^D","^D","~$mikron.codegen.diff","^M"],"~:uses",null,"~:defs",["^ ","~$allocate-buffer",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","~$mikron.core","~:line",79,"~:column",7,"~:end-line",79,"~:end-column",22,"~:arglists",["~#list",["~$quote",["^Z",[["~$size"]]]]],"~:doc","Allocates a new buffer with the given `size`.\n   ~~~klipse\n   (allocate-buffer 2048)\n   ~~~"],"^8","~$mikron.core$macros/allocate-buffer","~:variadic",false,"^S","mikron/core.cljc","^X",22,"~:method-params",["^Z",[["^10"]]],"~:protocol-impl",null,"~:arglists-meta",["^Z",[null,null]],"^V",1,"^U",79,"^W",79,"~:max-fixed-arity",1,"~:fn-var",true,"^Y",["^Z",["^[",["^Z",[["^10"]]]]],"^11","Allocates a new buffer with the given `size`.\n   ~~~klipse\n   (allocate-buffer 2048)\n   ~~~"],"~$pack",["^ ","^Q",null,"^R",["^ ","^S","^T","^U",111,"^V",7,"^W",111,"^X",11,"^Y",["^Z",["^[",["^Z",[["~$schema","~$value"]]]]],"^11","Packs `value`, which must conform to `schema`, and may be an instance of `DiffedValue`.\n   ~~~klipse\n   (let [my-schema (schema [:tuple [:int :keyword]])]\n     (pack my-schema [100 :cat]))\n   ~~~"],"^8","~$mikron.core$macros/pack","^13",false,"^S","mikron/core.cljc","^X",11,"^14",["^Z",[["^1:","^1;"]]],"^15",null,"^16",["^Z",[null,null]],"^V",1,"^U",111,"^W",111,"^17",2,"^18",true,"^Y",["^Z",["^[",["^Z",[["^1:","^1;"]]]]],"^11","Packs `value`, which must conform to `schema`, and may be an instance of `DiffedValue`.\n   ~~~klipse\n   (let [my-schema (schema [:tuple [:int :keyword]])]\n     (pack my-schema [100 :cat]))\n   ~~~"],"~$dependencies",["^ ","^Q",null,"^R",["^ ","^S","^T","^U",31,"^V",17,"^W",31,"^X",29,"~:private",true,"^Y",["^Z",["^[",["^Z",[["~$processors"]]]]],"^11","Returns all the processor dependencies of the given processors."],"^1>",true,"^8","~$mikron.core$macros/dependencies","^13",false,"^S","mikron/core.cljc","^X",29,"^14",["^Z",[["^1?"]]],"^15",null,"^16",["^Z",[null,null]],"^V",1,"^U",31,"^W",31,"^17",1,"^18",true,"^Y",["^Z",["^[",["^Z",[["^1?"]]]]],"^11","Returns all the processor dependencies of the given processors."],"~$diff",["^ ","^Q",null,"^R",["^ ","^S","^T","^U",191,"^V",7,"^W",191,"^X",11,"^Y",["^Z",["^[",["^Z",[["^1:","~$value-1","~$value-2"]]]]],"^11","Returns the diff between the old (`value-1`) and the new (`value-2`) value, both conforming to `schema`.\n   Wraps the return value with `DiffedValue` for `pack` and `undiff` consumption.\n   ~~~klipse\n   (let [my-schema (schema [:map :byte :keyword]\n                           :diff {:all true})]\n     (diff my-schema {0 :a 1 :b} {0 :a 1 :c 2 :d}))\n   ~~~"],"^8","~$mikron.core$macros/diff","^13",false,"^S","mikron/core.cljc","^X",11,"^14",["^Z",[["^1:","^1B","^1C"]]],"^15",null,"^16",["^Z",[null,null]],"^V",1,"^U",191,"^W",191,"^17",3,"^18",true,"^Y",["^Z",["^[",["^Z",[["^1:","^1B","^1C"]]]]],"^11","Returns the diff between the old (`value-1`) and the new (`value-2`) value, both conforming to `schema`.\n   Wraps the return value with `DiffedValue` for `pack` and `undiff` consumption.\n   ~~~klipse\n   (let [my-schema (schema [:map :byte :keyword]\n                           :diff {:all true})]\n     (diff my-schema {0 :a 1 :b} {0 :a 1 :c 2 :d}))\n   ~~~"],"~$*buffer*",["^ ","^R",["^ ","^S","^T","^U",75,"^V",26,"^W",75,"^X",34,"^1>",true,"~:dynamic",true],"^1>",true,"^8","~$mikron.core$macros/*buffer*","^S","mikron/core.cljc","^X",34,"^V",1,"^1F",true,"^U",75,"^W",75,"~:tag","~$any","^11","The default buffer with 10Kb size."],"^1:",["^ ","^Q",null,"^R",["^ ","^S","^T","^X",17,"~:top-fn",["^ ","^13",true,"^17",2,"^14",[["^Z",["~$&form","~$&env","~$args"]]],"^Y",["^Z",[["^1K","^1L","~$&","^1M"]]],"^16",["^Z",[null]]],"^V",11,"^U",51,"~:macro",true,"^W",51,"^Y",["^Z",["^[",["^Z",[["~$&","^1M"]]]]],"^11","Creates a new schema.\n   ~~~klipse\n   (def my-schema\n     (schema [:tuple [:int :string [:enum [:a :b :c]]]]))\n   ~~~"],"^8","~$mikron.core$macros/schema","^13",true,"^S","mikron/core.cljc","^X",17,"^1J",["^ ","^13",true,"^17",2,"^14",[["^Z",["^1K","^1L","^1M"]]],"^Y",["^Z",[["^1K","^1L","~$&","^1M"]]],"^16",["^Z",[null]]],"^14",[["^Z",["^1K","^1L","^1M"]]],"^15",null,"^16",["^Z",[null]],"^V",1,"^U",51,"^1N",true,"^W",51,"^17",2,"^18",false,"^Y",["^Z",[["^1K","^1L","~$&","^1M"]]],"^11","Creates a new schema.\n   ~~~klipse\n   (def my-schema\n     (schema [:tuple [:int :string [:enum [:a :b :c]]]]))\n   ~~~"],"~$DiffedValue",["^ ","~:num-fields",1,"~:protocols",["^7",["~$cljs.core/IRecord","~$cljs.core/IEquiv","~$cljs.core/IHash","~$cljs.core/ICollection","~$cljs.core/ICounted","~$cljs.core/ISeqable","~$cljs.core/IMeta","~$cljs.core/ICloneable","~$cljs.core/IPrintWithWriter","~$cljs.core/IIterable","~$cljs.core/IWithMeta","~$cljs.core/IAssociative","~$cljs.core/IMap","~$cljs.core/ILookup"]],"^8","~$mikron.core$macros/DiffedValue","^S","mikron/core.cljc","^X",23,"~:type",true,"^V",12,"~:internal-ctor",true,"^U",104,"~:record",true,"^W",104,"~:skip-protocol-flag",["^7",["^1S","^1T","^1U","^1V","^1W","^1X","^1Y","^1Z","^1[","^21","^22","^23","^24"]]],"^1?",["^ ","^Q",null,"^R",["^ ","^S","^T","^U",24,"^V",17,"^W",24,"^X",27,"^1>",true,"^Y",["^Z",["^[",["^Z",[["~$env"]]]]],"^11","Returns all the generated processors for the given env."],"^1>",true,"^8","~$mikron.core$macros/processors","^13",false,"^S","mikron/core.cljc","^X",27,"^14",["^Z",[["^2:"]]],"^15",null,"^16",["^Z",[null,null]],"^V",1,"^U",24,"^W",24,"^17",1,"^18",true,"^Y",["^Z",["^[",["^Z",[["^2:"]]]]],"^11","Returns all the generated processors for the given env."],"~$valid?",["^ ","^Q",null,"^R",["^ ","^S","^T","^U",154,"^V",7,"^W",154,"^X",13,"^Y",["^Z",["^[",["^Z",[["^1:","^1;"]]]]],"^11","Returns `true` if `value` conforms to `schema`, `false` otherwise.\n   ~~~klipse\n   (let [my-schema (schema [:vector :byte])]\n     (valid? my-schema [0 1 2 3 4 5]))\n   ~~~"],"^8","~$mikron.core$macros/valid?","^13",false,"^S","mikron/core.cljc","^X",13,"^14",["^Z",[["^1:","^1;"]]],"^15",null,"^16",["^Z",[null,null]],"^V",1,"^U",154,"^W",154,"^17",2,"^18",true,"^Y",["^Z",["^[",["^Z",[["^1:","^1;"]]]]],"^11","Returns `true` if `value` conforms to `schema`, `false` otherwise.\n   ~~~klipse\n   (let [my-schema (schema [:vector :byte])]\n     (valid? my-schema [0 1 2 3 4 5]))\n   ~~~"],"~$undiff",["^ ","^Q",null,"^R",["^ ","^S","^T","^U",204,"^V",7,"^W",204,"^X",13,"^Y",["^Z",["^[",["^Z",[["^1:","^1B","^1C"]]]]],"^11","Returns the original value from the old (`value-1`) and the diffed (`value-2`) value. The old value must conform to\n   `schema`. `value-2` must be an instance of `DiffedValue`.\n   ~~~klipse\n   (let [my-schema (schema [:map :byte :keyword]\n                           :diff {:all true})\n         old-value {0 :a 1 :b}]\n     (->> {0 :a 1 :c 2 :d} (diff my-schema old-value) (undiff my-schema old-value)))\n   ~~~"],"^8","~$mikron.core$macros/undiff","^13",false,"^S","mikron/core.cljc","^X",13,"^14",["^Z",[["^1:","^1B","^1C"]]],"^15",null,"^16",["^Z",[null,null]],"^V",1,"^U",204,"^W",204,"^17",3,"^18",true,"^Y",["^Z",["^[",["^Z",[["^1:","^1B","^1C"]]]]],"^11","Returns the original value from the old (`value-1`) and the diffed (`value-2`) value. The old value must conform to\n   `schema`. `value-2` must be an instance of `DiffedValue`.\n   ~~~klipse\n   (let [my-schema (schema [:map :byte :keyword]\n                           :diff {:all true})\n         old-value {0 :a 1 :b}]\n     (->> {0 :a 1 :c 2 :d} (diff my-schema old-value) (undiff my-schema old-value)))\n   ~~~"],"~$set-byte-buffer-factory!",["^ ","^Q",null,"^R",["^ ","^S","^T","^U",88,"^V",7,"^W",88,"^X",31,"^Y",["^Z",["^[",["^Z",[["~$factory"]]]]],"^11","Sets the byte buffer factory."],"^8","~$mikron.core$macros/set-byte-buffer-factory!","^13",false,"^S","mikron/core.cljc","^X",31,"^14",["^Z",[["^2A"]]],"^15",null,"^16",["^Z",[null,null]],"^V",1,"^U",88,"^W",88,"^17",1,"^18",true,"^Y",["^Z",["^[",["^Z",[["^2A"]]]]],"^11","Sets the byte buffer factory."],"~$gen",["^ ","^Q",null,"^R",["^ ","^S","^T","^U",143,"^V",7,"^W",143,"^X",10,"^Y",["^Z",["^[",["^Z",[["^1:"]]]]],"^11","Generates a new value which conforms to `schema`.\n   ~~~klipse\n   (let [my-schema (schema [:multi number? {true :ubyte false [:enum [:a :b :c]]}])]\n     (repeatedly 10 #(gen my-schema)))\n   ~~~"],"^8","~$mikron.core$macros/gen","^13",false,"^S","mikron/core.cljc","^X",10,"^14",["^Z",[["^1:"]]],"^15",null,"^16",["^Z",[null,null]],"^V",1,"^U",143,"^W",143,"^17",1,"^18",true,"^Y",["^Z",["^[",["^Z",[["^1:"]]]]],"^11","Generates a new value which conforms to `schema`.\n   ~~~klipse\n   (let [my-schema (schema [:multi number? {true :ubyte false [:enum [:a :b :c]]}])]\n     (repeatedly 10 #(gen my-schema)))\n   ~~~"],"~$diffed?",["^ ","^Q",null,"^R",["^ ","^S","^T","^U",106,"^V",17,"^W",106,"^X",24,"^1>",true,"^Y",["^Z",["^[",["^Z",[["^1;"]]]]],"^11","Returns `true` if `value` is diffed, `false` otherwise."],"^1>",true,"^8","~$mikron.core$macros/diffed?","^13",false,"^S","mikron/core.cljc","^X",24,"^14",["^Z",[["^1;"]]],"^15",null,"^16",["^Z",[null,null]],"^V",1,"^U",106,"^W",106,"^17",1,"^18",true,"^Y",["^Z",["^[",["^Z",[["^1;"]]]]],"^11","Returns `true` if `value` is diffed, `false` otherwise."],"~$defschema",["^ ","^Q",null,"^R",["^ ","^S","^T","^X",20,"^1J",["^ ","^13",true,"^17",2,"^14",[["^Z",["^1K","^1L","^1M"]]],"^Y",["^Z",[["^1K","^1L","~$&","^1M"]]],"^16",["^Z",[null]]],"^V",11,"^U",62,"^1N",true,"^W",62,"^Y",["^Z",["^[",["^Z",[["~$&","^1M"]]]]],"^11","Creates a new schema and binds it to the given symbol.\n   ~~~klipse\n   (defschema my-schema\n     [:record {:a :keyword :b :ubyte}])\n   ~~~"],"^8","~$mikron.core$macros/defschema","^13",true,"^S","mikron/core.cljc","^X",20,"^1J",["^ ","^13",true,"^17",2,"^14",[["^Z",["^1K","^1L","^1M"]]],"^Y",["^Z",[["^1K","^1L","~$&","^1M"]]],"^16",["^Z",[null]]],"^14",[["^Z",["^1K","^1L","^1M"]]],"^15",null,"^16",["^Z",[null]],"^V",1,"^U",62,"^1N",true,"^W",62,"^17",2,"^18",false,"^Y",["^Z",[["^1K","^1L","~$&","^1M"]]],"^11","Creates a new schema and binds it to the given symbol.\n   ~~~klipse\n   (defschema my-schema\n     [:record {:a :keyword :b :ubyte}])\n   ~~~"],"~$unpack",["^ ","^Q",null,"^R",["^ ","^S","^T","^U",127,"^V",7,"^W",127,"^X",13,"^Y",["^Z",["^[",["^Z",[["^1:","~$binary"]]]]],"^11","Unpacks a value (which conforms to `schema`) from the binary value `binary`.\n   ~~~klipse\n   (let [my-schema (schema [:tuple [:int :keyword]])]\n     (->> [100 :cat] (pack my-schema) (unpack my-schema)))\n   ~~~"],"^8","~$mikron.core$macros/unpack","^13",false,"^S","mikron/core.cljc","^X",13,"^14",["^Z",[["^1:","^2J"]]],"^15",null,"^16",["^Z",[null,null]],"^V",1,"^U",127,"^W",127,"^17",2,"^18",true,"^Y",["^Z",["^[",["^Z",[["^1:","^2J"]]]]],"^11","Unpacks a value (which conforms to `schema`) from the binary value `binary`.\n   ~~~klipse\n   (let [my-schema (schema [:tuple [:int :keyword]])]\n     (->> [100 :cat] (pack my-schema) (unpack my-schema)))\n   ~~~"],"~$diff*",["^ ","^Q",null,"^R",["^ ","^S","^T","^U",165,"^V",7,"^W",165,"^X",12,"^Y",["^Z",["^[",["^Z",[["^1:","^1B","^1C"]]]]],"^11","Returns the diff between the old (`value-1`) and the new (`value-2`) value, both conforming to `schema`.\n   ~~~klipse\n   (let [my-schema (schema [:vector [:enum [:a :b]]]\n                           :diff {:all true})]\n     (diff* my-schema [:a :b :a :a] [:b :b :a :b]))\n   ~~~"],"^8","~$mikron.core$macros/diff*","^13",false,"^S","mikron/core.cljc","^X",12,"^14",["^Z",[["^1:","^1B","^1C"]]],"^15",null,"^16",["^Z",[null,null]],"^V",1,"^U",165,"^W",165,"^17",3,"^18",true,"^Y",["^Z",["^[",["^Z",[["^1:","^1B","^1C"]]]]],"^11","Returns the diff between the old (`value-1`) and the new (`value-2`) value, both conforming to `schema`.\n   ~~~klipse\n   (let [my-schema (schema [:vector [:enum [:a :b]]]\n                           :diff {:all true})]\n     (diff* my-schema [:a :b :a :a] [:b :b :a :b]))\n   ~~~"],"~$->DiffedValue",["^ ","^Q",null,"^R",["^ ","^S","^T","^U",104,"^V",12,"^W",104,"^X",23,"^27",true,"~:factory","~:positional","^Y",["^Z",["^[",["^Z",[["^1;"]]]]]],"^8","~$mikron.core$macros/->DiffedValue","^13",false,"^S","mikron/core.cljc","^X",23,"^14",["^Z",[["^1;"]]],"^15",null,"^16",["^Z",[null,null]],"^V",1,"^27",true,"^2O","^2P","^U",104,"^W",104,"^17",1,"^18",true,"^Y",["^Z",["^[",["^Z",[["^1;"]]]]]],"~$->Schema",["^ ","^Q",null,"^R",["^ ","^S","^T","^U",17,"^V",12,"^W",17,"^X",18,"^27",true,"^2O","^2P","^Y",["^Z",["^[",["^Z",[["^1?"]]]]]],"^8","~$mikron.core$macros/->Schema","^13",false,"^S","mikron/core.cljc","^X",18,"^14",["^Z",[["^1?"]]],"^15",null,"^16",["^Z",[null,null]],"^V",1,"^27",true,"^2O","^2P","^U",17,"^W",17,"^17",1,"^18",true,"^Y",["^Z",["^[",["^Z",[["^1?"]]]]]],"~$schema*",["^ ","^Q",null,"^R",["^ ","^S","^T","^U",39,"^V",7,"^W",39,"^X",14,"^Y",["^Z",["^[",["^Z",[["~$&","^1M"]]]]],"^11","Generates all the processor related code for the given env.","^1J",["^ ","^13",true,"^17",0,"^14",[["^Z",["^1M"]]],"^Y",["^Z",[["~$&","^1M"]]],"^16",["^Z",[null]]]],"^8","~$mikron.core$macros/schema*","^13",true,"^S","mikron/core.cljc","^X",14,"^1J",["^ ","^13",true,"^17",0,"^14",[["^Z",["^1M"]]],"^Y",["^Z",[["~$&","^1M"]]],"^16",["^Z",[null]]],"^14",[["^Z",["^1M"]]],"^15",null,"^16",["^Z",[null]],"^V",1,"^U",39,"^W",39,"^17",0,"^18",true,"^Y",["^Z",[["~$&","^1M"]]],"^11","Generates all the processor related code for the given env."],"~$schema?",["^ ","^Q",null,"^R",["^ ","^S","^T","^U",19,"^V",7,"^W",19,"^X",14,"^Y",["^Z",["^[",["^Z",[["^1;"]]]]],"^11","Returns `true` if `value` is an instance of `Schema`, `false` otherwise."],"^8","~$mikron.core$macros/schema?","^13",false,"^S","mikron/core.cljc","^X",14,"^14",["^Z",[["^1;"]]],"^15",null,"^16",["^Z",[null,null]],"^V",1,"^U",19,"^W",19,"^17",1,"^18",true,"^Y",["^Z",["^[",["^Z",[["^1;"]]]]],"^11","Returns `true` if `value` is an instance of `Schema`, `false` otherwise."],"~$map->DiffedValue",["^ ","^Q",null,"^R",["^ ","^S","^T","^U",104,"^V",12,"^W",104,"^X",23,"^27",true,"^2O","~:map","^Y",["^Z",["^[",["^Z",[["~$G__859"]]]]]],"^8","~$mikron.core$macros/map->DiffedValue","^13",false,"^S","mikron/core.cljc","^X",23,"^14",["^Z",[["^2Z"]]],"^15",null,"^16",["^Z",[null,null]],"^V",1,"^27",true,"^2O","^2Y","^U",104,"^W",104,"^17",1,"^18",true,"^Y",["^Z",["^[",["^Z",[["^2Z"]]]]]],"~$interp",["^ ","^Q",null,"^R",["^ ","^S","^T","^U",218,"^V",7,"^W",218,"^X",13,"^Y",["^Z",["^[",["^Z",[["^1:","^1B","^1C","~$time-1","~$time-2","~$time"]]]]],"^11","Calculates a new value of an entity at `time`, given two other values (`value-1` and `value-2`, both conforming to\n   `schema`) and their respective timestamps (`time-1` and `time-2`). Uses linear interpolation.\n   ~~~klipse\n   (let [my-schema (schema [:record {:a :float :b [:vector :float]}]\n                           :interp {:a true :b {:all true}})]\n     (interp my-schema {:a 10 :b [1 2 3]} {:a 20 :b [4 5 6 7]} 0 1 0.5))\n   ~~~"],"^8","~$mikron.core$macros/interp","^13",false,"^S","mikron/core.cljc","^X",13,"^14",["^Z",[["^1:","^1B","^1C","^31","^32","^33"]]],"^15",null,"^16",["^Z",[null,null]],"^V",1,"^U",218,"^W",218,"^17",6,"^18",true,"^Y",["^Z",["^[",["^Z",[["^1:","^1B","^1C","^31","^32","^33"]]]]],"^11","Calculates a new value of an entity at `time`, given two other values (`value-1` and `value-2`, both conforming to\n   `schema`) and their respective timestamps (`time-1` and `time-2`). Uses linear interpolation.\n   ~~~klipse\n   (let [my-schema (schema [:record {:a :float :b [:vector :float]}]\n                           :interp {:a true :b {:all true}})]\n     (interp my-schema {:a 10 :b [1 2 3]} {:a 20 :b [4 5 6 7]} 0 1 0.5))\n   ~~~"],"~$with-buffer",["^ ","^Q",null,"^R",["^ ","^S","^T","^X",22,"^1J",["^ ","^13",true,"^17",3,"^14",[["^Z",["^1K","^1L","^A","~$body"]]],"^Y",["^Z",[["^1K","^1L","^A","~$&","^36"]]],"^16",["^Z",[null]]],"^V",11,"^U",93,"^1N",true,"^W",93,"^Y",["^Z",["^[",["^Z",[["^A","~$&","^36"]]]]],"^11","Executes all the expressions of `body` in the context of `buffer`.\n   ~~~klipse\n   (let [my-schema (schema [:list :int])]\n     (with-buffer (allocate-buffer 10000)\n       (pack my-schema (repeatedly 2000 #(rand-int 1000)))))\n   ~~~"],"^8","~$mikron.core$macros/with-buffer","^13",true,"^S","mikron/core.cljc","^X",22,"^1J",["^ ","^13",true,"^17",3,"^14",[["^Z",["^1K","^1L","^A","^36"]]],"^Y",["^Z",[["^1K","^1L","^A","~$&","^36"]]],"^16",["^Z",[null]]],"^14",[["^Z",["^1K","^1L","^A","^36"]]],"^15",null,"^16",["^Z",[null]],"^V",1,"^U",93,"^1N",true,"^W",93,"^17",3,"^18",false,"^Y",["^Z",[["^1K","^1L","^A","~$&","^36"]]],"^11","Executes all the expressions of `body` in the context of `buffer`.\n   ~~~klipse\n   (let [my-schema (schema [:list :int])]\n     (with-buffer (allocate-buffer 10000)\n       (pack my-schema (repeatedly 2000 #(rand-int 1000)))))\n   ~~~"],"~$map->Schema",["^ ","^Q",null,"^R",["^ ","^S","^T","^U",17,"^V",12,"^W",17,"^X",18,"^27",true,"^2O","^2Y","^Y",["^Z",["^[",["^Z",[["~$G__813"]]]]]],"^8","~$mikron.core$macros/map->Schema","^13",false,"^S","mikron/core.cljc","^X",18,"^14",["^Z",[["^39"]]],"^15",null,"^16",["^Z",[null,null]],"^V",1,"^27",true,"^2O","^2Y","^U",17,"^W",17,"^17",1,"^18",true,"^Y",["^Z",["^[",["^Z",[["^39"]]]]]],"~$Schema",["^ ","^1Q",1,"^1R",["^7",["^1S","^1T","^1U","^1V","^1W","^1X","^1Y","^1Z","^1[","^20","^21","^22","^23","^24"]],"^8","~$mikron.core$macros/Schema","^S","mikron/core.cljc","^X",18,"^26",true,"^V",12,"^27",true,"^U",17,"^28",true,"^W",17,"^29",["^7",["^1S","^1T","^1U","^1V","^1W","^1X","^1Y","^1Z","^1[","^21","^22","^23","^24"]]],"~$undiff*",["^ ","^Q",null,"^R",["^ ","^S","^T","^U",177,"^V",7,"^W",177,"^X",14,"^Y",["^Z",["^[",["^Z",[["^1:","^1B","^1C"]]]]],"^11","Returns the original value from the old (`value-1`) and the diffed (`value-2`) value.\n   The old value must conform to `schema`.\n   ~~~klipse\n   (let [my-schema (schema [:vector [:enum [:a :b]]]\n                           :diff {:all true})\n         old-value [:a :b :a :a]]\n     (->> [:b :b :a :b] (diff* my-schema old-value) (undiff* my-schema old-value)))\n   ~~~"],"^8","~$mikron.core$macros/undiff*","^13",false,"^S","mikron/core.cljc","^X",14,"^14",["^Z",[["^1:","^1B","^1C"]]],"^15",null,"^16",["^Z",[null,null]],"^V",1,"^U",177,"^W",177,"^17",3,"^18",true,"^Y",["^Z",["^[",["^Z",[["^1:","^1B","^1C"]]]]],"^11","Returns the original value from the old (`value-1`) and the diffed (`value-2`) value.\n   The old value must conform to `schema`.\n   ~~~klipse\n   (let [my-schema (schema [:vector [:enum [:a :b]]]\n                           :diff {:all true})\n         old-value [:a :b :a :a]]\n     (->> [:b :b :a :b] (diff* my-schema old-value) (undiff* my-schema old-value)))\n   ~~~"]],"~:require-macros",["^ ","^B","^<","^<","^<","^F","^=","^=","^="],"~:cljs.analyzer/constants",["^ ","~:seen",["^7",["~:mikron.spec/schema*-args","~:args","~$&","^36","~$cljs.core/binding","^32","~:unpack-diffed","^12","^P","^19","^1<","^9","^1=","^1@","~:processors","~:valid?","^A","~:diffed?","^1D","^1A","^1>","~:else","~:undiff","~:gen","^2J","^1E","^1G","^1M","~:schema*-args","~:processor-fn","~:ns","^1:","^1O","^8","^1K","^13","~:value","^S","~$.-processors","~:unpack","^X","^1J","~$mikron.core/Schema.","^2=","^2;","^1?","^2<","^2?","^2>","^14","^2B","^2@","^2C","^2D","^2E","^2F","^16","~:doc-string","^39","~:processor-type","^2H","^2G","^V","^1;","^27","~$cljs.core/let","^1C","^2K","^2I","^33","^2P","~$mikron.core/*buffer*","^2L","^2M","^2O","^31","^2N","^2Q","~:interp","^1F","^U","^2Z","^1N","^2:","~:mikron.spec/schema-args","~:mikron.spec/defschema-args","^2R","^2S","^1L","^2T","^2U","^2V","^2W","~$cljs.core/fn","~:mikron/invalid","^10","^W","^1B","^2[","^2X","^17","^2A","^30","^34","^Y","~:pack-diffed","^37","^35","~$cljs.spec/fspec","^11","^3:","^38","^2Y","~:pack","~:test","~:schema-name","~$def","~:diff","^3>","^3="]],"~:order",["^3F","^1?","^2S","^3N","^8","^S","^X","^V","^27","^2O","^U","^W","^Y","^11","^43","^9","^2R","^2P","^3:","^38","^2Y","^39","^2W","^2V","^1;","^3T","^3M","^3Z","^2;","^1>","^2:","^44","^1@","^1=","^2U","^1J","^2T","^13","^17","^14","^16","^1M","~$&","^3B","^3U","^3P","^3R","^1O","^1N","^1:","^1K","^1L","^41","^3C","^3X","^2H","^2G","^3Y","^3S","^3L","^45","^1G","^1F","^1E","^12","^P","^10","^2B","^2@","^2A","^37","^35","^A","^36","^3D","^3V","^3O","^2Q","^2N","^2[","^2X","^2Z","^2F","^2E","^40","^42","^1<","^19","^3[","^3I","^3H","^3E","^3Q","^2K","^2I","^2J","^3K","^2D","^2C","^3G","^2=","^2<","^46","^2M","^2L","^1B","^1C","^3J","^3>","^3=","^1D","^1A","^2?","^2>","^3W","^34","^30","^31","^32","^33"]],"^11","Core namespace."]